/* 
   
   Copyright (C) 1999, 2000, 2001 Juniper Networks Inc.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
   USA.  
   
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../include/compiler_macro.h"
#include "../include/link_error_msg.h"
#include "../include/linker.h"
#include "../include/codegen_macro.h"
#include "./vinst.tab.h"

#include "../include/jeda_pli.h"

#define FATAL_ERROR exit(1)

void out_indent() ;

extern char *out_v_fname ;
extern char *out_vtop_fname ;
extern char *out_fname ;
extern int JL_verilog_top_mode ;
extern int JL_standalone_mode ;
extern int JL_vpi_mode ;

extern vcode_info  *JD_top_inst ;

FILE *vout ;
extern FILE *out ;

static int hash_value ;
static int last_hash_value ;

static void calc_hash( char *p ) {
  /* fprintf( stderr, "%d on %s\n", hash_value, p ) ; */
  while( *p != '\0' ){ hash_value += *p ; p++ ; }
}

static void add_hash( int n ) {
  /* fprintf( stderr, "%d on %d\n", hash_value, n ) ; */
  hash_value += n ; 
}

static void out_header() {
  VOUT0( 
    "/**********************************************************************\n"
  );
  VOUT0(
    "*  JEDA verilog module created by JEDA linker\n"
  );
  VOUT0(
    "*    WARNING: DO NOT EDIT THIS FILE MANUALLY!!\n"
  );
  VOUT0( 
    "**********************************************************************/\n"
  );
}

static void check_add_connection( char *pset, vcode_info *this, char *path ) {
  vcode_info *attrib ;

  attrib = this->is.port.attribs ;
  
  while( attrib ) {
    if( attrib->type == JD_port_path_attrib ) {
      if( strcmp( attrib->is.string, path ) ) {
        fprintf( stderr,
          "JEDA Link Error: Multiple connection to port %s%s%s defined, \"%s\", \"%s\"\n",
          (pset==NULL)?"":pset, (pset==NULL)?"":".", this->is.port.name,
          attrib->is.string, path
        ) ;
        exit(1) ; 
      }
    }
    attrib = attrib->next ;
  }
  
  /* add the connection attrib to the info */
  attrib = ALLOC(vcode_info) ;
  attrib->type = JD_port_path_attrib ;
  attrib->is.string = path ;
  attrib->next = this->is.port.attribs ;
  this->is.port.attribs = attrib ;
  
}

static vcode_info *get_connection_attrib( vcode_info *this ) {
  vcode_info *attrib ;
  attrib = this->is.port.attribs ;

  while( attrib ) {
    if( attrib->type == JD_port_path_attrib ) {
      return attrib ; 
    }
    attrib = attrib->next ;
  }
  return NULL ;
}

static int get_drive_skew( vcode_info *this ) {
  vcode_info *attrib ;
  attrib = this->is.port.attribs ;

  while( attrib ) {
    if( attrib->type == JD_port_access_attrib && 
      attrib->is.port_access_attrib.drive_sample == VI_drive ) 
    {
      return attrib->is.port_access_attrib.skew  ; 
    }
    attrib = attrib->next ;
  }
  return 0 ;
}

static int get_sample_skew( vcode_info *this ) {
  vcode_info *attrib ;
  attrib = this->is.port.attribs ;

  while( attrib ) {
    if( attrib->type == JD_port_access_attrib && 
      attrib->is.port_access_attrib.drive_sample == VI_sample ) 
    {
      return attrib->is.port_access_attrib.skew  ; 
    }
    attrib = attrib->next ;
  }
  return 0 ;
}

static int get_drive_edge( vcode_info *this ) {
  vcode_info *attrib ;
  attrib = this->is.port.attribs ;

  while( attrib ) {
    if( attrib->type == JD_port_access_attrib && 
      attrib->is.port_access_attrib.drive_sample == VI_drive ) 
    {
      return attrib->is.port_access_attrib.edge  ; 
    }
    attrib = attrib->next ;
  }
  
  return 0 ;
}

static int get_sample_edge( vcode_info *this ) {
  vcode_info *attrib ;
  attrib = this->is.port.attribs ;

  while( attrib ) {
    if( attrib->type == JD_port_access_attrib && 
      attrib->is.port_access_attrib.drive_sample == VI_sample ) 
    {
      return attrib->is.port_access_attrib.edge  ; 
    }
    attrib = attrib->next ;
  }
  return 0 ;
}

static  int get_depth( vcode_info *this ) {
  vcode_info *attrib ;
  attrib = this->is.port.attribs ;

  while( attrib ) {
    if( attrib->type == JD_port_depth_attrib ) {
      return attrib->is.int_value ; 
    }
    attrib = attrib->next ;
  }
  return 0 ;
}

static vcode_info *get_clock_attrib( vcode_info *this ) {
  vcode_info *attrib ;
  attrib = this->is.port.attribs ;

  while( attrib ) {
    if( attrib->type == JD_port_clock_attrib  ) 
    {
      return attrib ; 
    }
    attrib = attrib->next ;
  }
  return NULL ;
}

static void resolve_connection()
{
  vcode_info *this ;
  char *portset, *port, *path ;
  JD_name *name, *ptname ;
  
  this = JD_top_inst ;
  while( this ) {
    if( this->type == JD_connection_info ) {
      portset = this->is.connection_info.portset ;
      port = this->is.connection_info.port ;
      path = this->is.connection_info.path ;
      if( portset == NULL ) {
        name = find_global_name( port ) ;
        if( !name ) {
          fprintf( 
            stderr, "JEDA Linker fatal error: Undefined port name %s for connection detected\n",
            port
          ) ;
          exit(1) ;
        }
        check_add_connection( NULL, name->info, path ) ;
      }
      else {
        name = find_global_name( portset ) ;
        if( !name ) {
          fprintf( 
            stderr, "JEDA Linker fatal error: Undefined portset name %s for connection detected\n",
            portset
          ) ;
          exit(1) ;
        }
        ptname = find_name_in_scope( port, name->child ) ;
        if( !ptname ) {
          fprintf( 
            stderr, "JEDA Linker fatal error: Undefined port name %s for connection detected\n",
            port
          ) ;
          exit(1) ;
        }
        check_add_connection( portset, ptname->info, path ) ;
      }
    }
    this = this->next ;
  }

}

static void out_port_list() {
  vcode_info *this, *pt ;
  char *pset_name ;
  
  VOUT0( "  CLOCK" ) ;
  this = JD_top_inst ;
  
  /* output port list */
  while( this ) {
    switch( this->type ) {
      case JD_port_info:
        if( get_connection_attrib(this) == NULL ) {
          VOUT0( ",\n" ) ;
          VOUT1( "  %s", this->is.port.name ) ;
          calc_hash( this->is.port.name ) ;
        }
        break ;
      case JD_portset_info:
        pset_name = this->is.portset.name ;
        pt = this->is.portset.port_infos ;
        while( pt ) {
          if( pt->type == JD_port_info ) {
            if( get_connection_attrib(pt) == NULL ) {
              VOUT0( ",\n" ) ;
              VOUT2( "  %s_%s", pset_name, pt->is.port.name ) ;
              calc_hash( pset_name ) ;
              calc_hash( pt->is.port.name ) ;
            }
          }
          pt = pt->next ;
        }
        break ;
      default:
        break ;
    }
    this = this->next ;
  }

}


static void out_port_dcl() {
  vcode_info *this, *pt ;
  char *pset_name ;
  
  
    VOUT0( "  inout CLOCK ;\n" ) ;
  this = JD_top_inst ;

  this = JD_top_inst ;
  
  /* output port list */
  while( this ) {
    switch( this->type ) {
      case JD_port_info:
        if( get_connection_attrib(this) == NULL ) {
          switch( this->is.port.direction ) {
            case VI_input: VOUT0( "  input" ) ; break ;
            case VI_output: VOUT0( "  output" ) ; break ;
            case VI_inout: VOUT0( "  inout" ) ; break ;
          }
          if( this->is.port.ub || this->is.port.lb ) {
            VOUT2( " [%d:%d]", this->is.port.ub, this->is.port.lb ) ;
            add_hash( this->is.port.ub ) ;
            add_hash( this->is.port.lb );
          }
          VOUT1( " %s ;\n", this->is.port.name ) ;
          calc_hash( this->is.port.name ) ;
        }
        break ;
      case JD_portset_info:
        pset_name = this->is.portset.name ;
        pt = this->is.portset.port_infos ;
        while( pt ) {
          if( pt->type == JD_port_info ) {
            if( get_connection_attrib(pt) == NULL ) {
              switch( pt->is.port.direction ) {
                case VI_input: VOUT0( "  input" ) ; break ;
                case VI_output: VOUT0( "  output" ) ; break ;
                case VI_inout: VOUT0( "  inout" ) ; break ;
              }
              if( pt->is.port.ub || pt->is.port.lb ) {
                VOUT2( " [%d:%d]", pt->is.port.ub, pt->is.port.lb ) ;
                add_hash( pt->is.port.ub ) ;
                add_hash( pt->is.port.lb );
              }
              VOUT2( "  %s_%s ;\n", pset_name, pt->is.port.name ) ;
              calc_hash( pset_name ) ;
              calc_hash( pt->is.port.name ) ;
            }
          }
          pt = pt->next ;
        }
        break ;
      default:
        break ;
    }
    this = this->next ;
  }

}


static void out_port_connection_dcl() {
  vcode_info *this, *pt, *attr ;
  char *pset_name ;
  int skew ;
  

  VOUT0( "  wire jeda_in_CLOCK ;\n" ) ; 
  VOUT0( "  reg jeda_out_CLOCK ;\n" ) ; 
  VOUT0( "  assign jeda_in_CLOCK = CLOCK ;\n" ) ; 
  VOUT0( "  assign CLOCK = jeda_out_CLOCK ;\n" ) ; 
  this = JD_top_inst ;
  
  /* output port connection */
  while( this ) {
    switch( this->type ) {
      case JD_port_info:
        /* we don't care signal direction, and create inout structure for
           all the port */
        /* input structure */
        VOUT0( "  wire " ) ; 
        if( this->is.port.ub || this->is.port.lb ) {
          VOUT2( " [%d:%d]", this->is.port.ub, this->is.port.lb ) ;
          add_hash( this->is.port.ub ) ;
          add_hash( this->is.port.lb );
        }
        VOUT1( " jeda_in_%s ;\n", this->is.port.name ) ;
        calc_hash( "jeda_in_" ) ;
        calc_hash( this->is.port.name ) ;
        skew = get_sample_skew(this) ;
        add_hash( skew ) ;
        if( (attr = get_connection_attrib(this)) ) {
          if( skew )
            VOUT2( "  assign #(%d,%d)", -skew, -skew ) ; 
          else 
            VOUT0( "  assign" ) ;
          VOUT2( 
            " jeda_in_%s = %s ;\n", this->is.port.name, attr->is.string
          ) ;
          calc_hash( this->is.port.name ) ;
          calc_hash( attr->is.string ) ;
        }
        else {
          if( skew )
            VOUT2( "  assign #(%d,%d)", -skew, -skew ) ; 
          else 
            VOUT0( "  assign" ) ;
          VOUT2( 
            " jeda_in_%s = %s ;\n", this->is.port.name, this->is.port.name
          ) ;
          calc_hash( this->is.port.name ) ;
          calc_hash( this->is.port.name ) ;
        }
        /* output structure */
        VOUT0( "  reg " ) ; 
        if( this->is.port.ub || this->is.port.lb ) {
          VOUT2( " [%d:%d]", this->is.port.ub, this->is.port.lb ) ;
          add_hash( this->is.port.ub ) ;
          add_hash( this->is.port.lb );
        }
        VOUT1( " jeda_out_%s ;\n", this->is.port.name ) ;
        calc_hash( "jeda_out_" ) ;
        calc_hash( this->is.port.name ) ;
        skew = get_drive_skew(this) ;
        add_hash( skew ) ;
        if( (attr = get_connection_attrib(this)) ) {
          if( skew )
            VOUT2( "  assign #(%d,%d)", skew, skew ) ; 
          else 
            VOUT0( "  assign" ) ;
          VOUT2( 
            " %s = jeda_out_%s ;\n", attr->is.string, this->is.port.name
          ) ;
          calc_hash( attr->is.string ) ;
          calc_hash( this->is.port.name ) ;
        }
        else {
          if( skew )
            VOUT2( "  assign #(%d,%d)", skew, skew ) ; 
          else 
            VOUT0( "  assign" ) ;
          VOUT2( 
            " %s = jeda_out_%s ;\n", this->is.port.name, this->is.port.name 
          ) ;
          calc_hash( this->is.port.name ) ;
          calc_hash( this->is.port.name ) ;
        }
        break ;
      case JD_portset_info:
        pset_name = this->is.portset.name ;
        pt = this->is.portset.port_infos ;
        while( pt ) {
          if( pt->type == JD_port_info ) {
            /* input structure */
            VOUT0( "  wire " ) ; 
            if( pt->is.port.ub || pt->is.port.lb ) {
              VOUT2( " [%d:%d]", pt->is.port.ub, pt->is.port.lb ) ;
              add_hash( pt->is.port.ub ) ;
              add_hash( pt->is.port.lb );
            }
            VOUT2( " jeda_in_%s_%s ;\n", pset_name, pt->is.port.name ) ;
            skew = get_sample_skew(pt) ;
            add_hash( skew ) ;
            if( (attr = get_connection_attrib(pt)) ) {
              if( skew )
                VOUT2( "  assign #(%d,%d)", -skew, -skew ) ; 
              else 
                VOUT0( "  assign" ) ;
              VOUT3( 
                " jeda_in_%s_%s = %s ;\n", 
                pset_name, pt->is.port.name, attr->is.string
              ) ;
              calc_hash( pset_name ) ;
              calc_hash( pt->is.port.name ) ;
              calc_hash( attr->is.string ) ;
            }
            else {
              if( skew )
                VOUT2( "  assign #(%d,%d)", -skew, -skew ) ; 
              else 
                VOUT0( "  assign" ) ;
              VOUT4( 
                " jeda_in_%s_%s = %s_%s ;\n", 
                pset_name, pt->is.port.name, pset_name, pt->is.port.name
              ) ;
              calc_hash( pset_name ) ;
              calc_hash( pt->is.port.name ) ;
              calc_hash( pset_name ) ;
              calc_hash( pt->is.port.name ) ;
            }
            /* output structure */
            VOUT0( "  reg " ) ; 
            if( pt->is.port.ub || pt->is.port.lb ) {
              VOUT2( " [%d:%d]", pt->is.port.ub, pt->is.port.lb ) ;
              add_hash( pt->is.port.ub ) ;
              add_hash( pt->is.port.lb );
            }
            VOUT2( " jeda_out_%s_%s ;\n", pset_name, pt->is.port.name ) ;
            skew = get_drive_skew(pt) ;
            add_hash( skew ) ;
            if( (attr = get_connection_attrib(pt)) ) {
              if( skew )
                VOUT2( "  assign #(%d,%d)", skew, skew ) ; 
              else 
                VOUT0( "  assign" ) ;
              VOUT3( 
                " %s = jeda_out_%s_%s ;\n", 
                attr->is.string, pset_name, pt->is.port.name
              ) ;
              calc_hash( attr->is.string ) ;
              calc_hash( pset_name ) ;
              calc_hash( pt->is.port.name ) ;
            }
            else {
              if( skew )
                VOUT2( "  assign #(%d,%d)", skew, skew ) ; 
              else 
                VOUT0( "  assign" ) ;
              VOUT4( 
                " %s_%s = jeda_out_%s_%s ;\n", 
                pset_name, pt->is.port.name, pset_name, pt->is.port.name 
              ) ;
              calc_hash( pset_name ) ;
              calc_hash( pt->is.port.name ) ;
              calc_hash( pset_name ) ;
              calc_hash( pt->is.port.name ) ;
            }
          }
          pt = pt->next ;
        }
        break ;
      default:
        break ;
    }
    this = this->next ;
  }

}


static void out_var_dcl( vcode_info *this ) {  
  vcode_info *attrib ;
  char *nm ;
  vcode_info *array_range, *data_type ;
  int dtype ;
  
  nm = this->is.variable_dcl.name ;
  dtype = this->is.variable_dcl.data_type->is.data_type.type ;
  data_type = this->is.variable_dcl.data_type ;
  attrib = this->is.variable_dcl.var_attrib ;

  if( attrib && attrib->is.attrib.is_local ) return ; /* no output on local */
    
  array_range = this->is.variable_dcl.array_range ;
  
  switch( array_range->is.array_range.type ) {
    case VI_single:
      switch( dtype ) {
        case VI_int:
          VOUT1( "  integer var_%s ; \n", nm ) ;
          calc_hash( "integer" ) ;
          calc_hash( nm ) ;
          break ;
        case VI_bit:
          if( data_type->is.data_type.ub || data_type->is.data_type.lb ) 
            VOUT2( 
              "  reg [%d:%d]", 
              data_type->is.data_type.ub, data_type->is.data_type.lb
            ) ;
          else 
            VOUT0( "  reg" ) ;
          add_hash( data_type->is.data_type.ub ) ;
          add_hash( data_type->is.data_type.lb );
          calc_hash( "bit" ) ;
          calc_hash( nm ) ;
          VOUT1( " var_%s ;\n", nm ) ;
          break ;
      }
      break ;
    case VI_array:
      switch( dtype ) {
        case VI_int:
          VOUT1( "  integer var_%s ", nm ) ;
          VOUT1( " [%d:0] ;\n", array_range->is.array_range.size-1 ) ;
          calc_hash( "integer array" ) ;
          calc_hash( nm ) ;
          add_hash( array_range->is.array_range.size ) ;
          break ;
        case VI_bit:
          if( data_type->is.data_type.ub || data_type->is.data_type.lb ) 
            VOUT2( 
              "  reg [%d:%d]", 
              data_type->is.data_type.ub, data_type->is.data_type.lb
            ) ;
          else 
            VOUT0( "  reg" ) ;
          VOUT1( " var_%s ", nm ) ;
          VOUT1( " [%d:0] ;\n", array_range->is.array_range.size-1 ) ;
          add_hash( data_type->is.data_type.ub );
          add_hash( data_type->is.data_type.lb );
          calc_hash( "bit array" ) ;
          calc_hash( nm ) ;
          add_hash( array_range->is.array_range.size ) ;
          break ;
      }
      break ;
  
  }
  
}

static void out_static_var_dcl( vcode_info *this ) {  
  vcode_info *attrib ;
  vcode_info *array_range ;
  int dtype ;
  char *cls, *fnc, *nm ;
  vcode_info *data_type ;
  
  data_type = this->is.static_var_dcl.data_type ;
  cls = this->is.static_var_dcl.class ;
  if( !strcmp(cls, "null") ) cls = "" ;
  fnc = this->is.static_var_dcl.func ;
  if( !strcmp(fnc, "null") ) fnc = "" ;
  nm = this->is.static_var_dcl.name ;
  
  dtype = this->is.static_var_dcl.data_type->is.data_type.type ;
  attrib = this->is.static_var_dcl.attribs ;

  if( attrib && attrib->is.attrib.is_local ) return ; /* no output on local */

  array_range = this->is.static_var_dcl.array_range ;
  
  switch( array_range->is.array_range.type ) {
    case VI_single:
      switch( dtype ) {
        case VI_int:
          VOUT3( "  integer svar_%s_%s_%s ; \n", cls, fnc, nm ) ;
          calc_hash( "static integer" ) ;
          calc_hash( cls ) ;
          calc_hash( fnc ) ;
          calc_hash( nm ) ;
          break ;
        case VI_bit:
          if( data_type->is.data_type.ub || data_type->is.data_type.lb ) 
            VOUT2( 
              "  reg [%d:%d]", 
              data_type->is.data_type.ub, data_type->is.data_type.lb
            ) ;
          else 
            VOUT0( "  reg" ) ;
          VOUT3( " svar_%s_%s_%s ; \n", cls, fnc, nm ) ;
          add_hash( data_type->is.data_type.ub ) ;
          add_hash( data_type->is.data_type.lb );
          calc_hash( "static bit" ) ;
          calc_hash( cls ) ;
          calc_hash( fnc ) ;
          calc_hash( nm ) ;
          break ;
      }
      break ;
    case VI_array:
      switch( dtype ) {
        case VI_int:
          VOUT3( "  integer svar_%s_%s_%s", cls, fnc, nm ) ;
          VOUT1( " [%d:0] ;\n", array_range->is.array_range.size-1 ) ;
          calc_hash( "static integer array" ) ;
          calc_hash( cls ) ;
          calc_hash( fnc ) ;
          calc_hash( nm ) ;
          add_hash( array_range->is.array_range.size );
          break ;
        case VI_bit:
          if( data_type->is.data_type.ub || data_type->is.data_type.lb ) 
            VOUT2( 
              "  reg [%d:%d]", 
              data_type->is.data_type.ub, data_type->is.data_type.lb
            ) ;
          else 
            VOUT0( "  reg" ) ;
          VOUT3( " svar_%s_%s_%s", cls, fnc, nm ) ;
          VOUT1( " [%d:0] ;\n", array_range->is.array_range.size-1 ) ;
          add_hash( data_type->is.data_type.ub ) ;
          add_hash( data_type->is.data_type.lb );
          calc_hash( "static bit array" ) ;
          calc_hash( cls ) ;
          calc_hash( fnc ) ;
          calc_hash( nm ) ;
          add_hash( array_range->is.array_range.size );
          break ;
      }
      break ;
  
  }

}

static void out_veri_task_dcl( vcode_info *this ) {  
  vcode_info *arg, *data_type ;
  char *nm, *path, *anm ;
  arg = this->is.function_info.arguments ;
  nm = this->is.function_info.name ;
  path = this->is.function_info.path ;
  
  VOUT2( "  //  Verilog task call %s -> %s\n", nm, path ) ;
  VOUT1( "  reg veri_task_%s_call ;\n", nm ) ;  
  VOUT1( "  reg veri_task_%s_done ;\n", nm ) ;
  VOUT1( "  initial veri_task_%s_call = 0 ;\n", nm ) ;
  VOUT1( "  initial veri_task_%s_done = 0 ;\n", nm ) ;
  calc_hash( "verilog task" ) ;
  calc_hash( nm ) ;
  while( arg ) {
    data_type = arg->is.argument.data_type ;
    anm = arg->is.argument.name ;
    switch( data_type->is.data_type.type ) {
      case VI_int:
        VOUT2( "  integer arg_%s_%s ; \n", nm, anm ) ;
        calc_hash( "integer arg" ) ;
        calc_hash( anm ) ;
        break ;
      case VI_bit:
        if( data_type->is.data_type.ub || data_type->is.data_type.lb ) 
          VOUT2( 
            "  reg [%d:%d]", 
            data_type->is.data_type.ub, data_type->is.data_type.lb
          ) ;
        else 
          VOUT0( "  reg" ) ;
        VOUT2( " arg_%s_%s ;\n", nm, anm ) ;
        add_hash( data_type->is.data_type.ub ) ;
        add_hash( data_type->is.data_type.lb ) ;
        calc_hash( "bit arg" ) ;
        calc_hash( anm ) ;
        break ;
    }
    arg = arg->next ;
  }

  arg = this->is.function_info.arguments ;
  VOUT1( 
    "  always @(posedge veri_task_%s_call) begin\n", 
    this->is.function_info.name
  ) ;
  VOUT2(
    "  // $display( \"  Jeda Verilog task %s is calling %s\" ) ;\n",
    this->is.function_info.name, this->is.function_info.path
  ) ;
  VOUT1( "    veri_task_%s_done = 0 ;\n", nm ) ;
  VOUT1( "    %s", this->is.function_info.path ) ;
  if( arg ) {
    VOUT0( "( " ) ;
    while( arg ) {
      anm = arg->is.argument.name ;
      VOUT2( "arg_%s_%s", nm, anm ) ;
      if( arg->next ) VOUT0( ", " ) ;
      arg = arg->next ;
    }
    VOUT0( " ) ;\n" ) ;
  }
  else VOUT0( " ;\n" ) ;
  VOUT1( "    veri_task_%s_call = 0 ;\n", nm ) ;
  VOUT1( "    veri_task_%s_done = 1 ;\n", nm ) ;
  VOUT0( "  end\n" ) ;
  
}

static void out_jeda_task_dcl( vcode_info *this, int index ) {  
  vcode_info *arg, *data_type ;
  char *nm, *anm ;
  int narg = 0 ;
  
  arg = this->is.function_info.arguments ;
  nm = this->is.function_info.name ;
  
  VOUT1( "  //  Verilog -> Jeda function %s\n", nm ) ;
  VOUT1( "  task %s ;\n", nm ) ;
  calc_hash( "jeda func" ) ;
  calc_hash( nm ) ;
  while( arg ) {
    narg++ ;
    data_type = arg->is.argument.data_type ;
    anm = arg->is.argument.name ;
    if( arg->is.argument.var ) VOUT0( "    inout" ) ;
    else VOUT0( "    input" ) ;
    switch( data_type->is.data_type.type ) {
      case VI_int:
        VOUT1( " [31:0] arg_%s ; \n", anm ) ;
        calc_hash( "integer jd_arg" ) ;
        calc_hash( anm ) ;
        break ;
      case VI_bit:
        if( data_type->is.data_type.ub || data_type->is.data_type.lb ) 
          VOUT2( 
            " [%d:%d]", 
            data_type->is.data_type.ub, data_type->is.data_type.lb
          ) ;
        VOUT1( " arg_%s ;\n", anm ) ;
        add_hash( data_type->is.data_type.ub ) ;
        add_hash( data_type->is.data_type.lb ) ;
        calc_hash( "bit jd_arg" ) ;
        calc_hash( anm ) ;
        break ;
    }
    arg = arg->next ;
  }

  arg = this->is.function_info.arguments ;
  VOUT1( "    reg %s_done ;\n", nm ) ;
  VOUT0( "    begin\n" ) ;
  VOUT1( "      %s_done = 0 ;\n", nm ) ;
  VOUT1(
    "      // $display( \"  Verilog is calling jeda function %s\" ) ;\n",
    nm
  ) ;
  if( JL_vpi_mode ) {
    VOUT5( "      $JEDA_vpi_task( %d, \"%s\", %d, %s_done, %d", 
      JEDA_LINK_JD_TASK, nm, index, nm, narg
    ) ;
  }
  else {
    VOUT5( "      $JEDA_task( %d, \"%s\", %d, %s_done, %d", 
      JEDA_LINK_JD_TASK, nm, index, nm, narg
    ) ;
  }
  if( arg ) {
    VOUT0( ", " ) ;
    while( arg ) {
      anm = arg->is.argument.name ;
      VOUT1( "arg_%s", anm ) ;
      if( arg->next ) VOUT0( ", " ) ;
      arg = arg->next ;
    }
  }
  VOUT0( " ) ;\n" ) ;
  VOUT1( "      @(%s_done) ;\n", nm ) ;
  VOUT1(
    "      // $display( \"  Verilog calling jeda function %s completed\" ) ;\n",
    this->is.function_info.name
  ) ;
  VOUT0( "    end\n" ) ;
  VOUT0( "  endtask\n" ) ;
  
}

static void out_port_link( vcode_info *this ) {  
  int size, dir ;
  /* connecting verilog structure to Jeda */
  switch( this->is.port.direction ) {
    case VI_input: dir = JEDA_INPUT ; break ;
    case VI_output: dir = JEDA_OUTPUT ; break ;
    case VI_inout: dir = JEDA_INOUT ; break ;
  }
  
  if( this->is.port.ub > this->is.port.lb ) 
    size = this->is.port.ub - this->is.port.lb + 1 ;
  else 
    size = this->is.port.lb - this->is.port.ub + 1 ;
  
  VOUT3(  "  jeda_out_%s = %d%cbz ;\n", this->is.port.name, size, '\'' ) ;
  if( JL_vpi_mode ) {
    VOUT6( 
      "  $JEDA_vpi_task( %d, \"%s\", \"?\", %d, %d, jeda_in_%s, jeda_out_%s  ) ;\n", 
      JEDA_LINK_PORT, this->is.port.name, 
      this->index, dir, this->is.port.name, this->is.port.name
    ) ;
  }
  else {
    VOUT6( 
      "  $JEDA_task( %d, \"%s\", \"?\", %d, %d, jeda_in_%s, jeda_out_%s  ) ;\n", 
      JEDA_LINK_PORT, this->is.port.name, 
      this->index, dir, this->is.port.name, this->is.port.name
    ) ;
  }
  
}  

static void out_portset_link( vcode_info *pset ) {  
  int size, dir ;
  vcode_info *this ;
  char *pset_name ;
  /* connecting verilog structure to Jeda */
  
  pset_name = pset->is.portset.name ;
  this = pset->is.portset.port_infos ;

  while( this ) {
    switch( this->is.port.direction ) {
      case VI_input: dir = JEDA_INPUT ; break ;
      case VI_output: dir = JEDA_OUTPUT ; break ;
      case VI_inout: dir = JEDA_INOUT ; break ;
    }
  
    if( this->is.port.ub > this->is.port.lb ) 
      size = this->is.port.ub - this->is.port.lb + 1 ;
    else 
      size = this->is.port.lb - this->is.port.ub + 1 ;
  
    VOUT3(  
      "  jeda_out_%s_%s = %d'bz ;\n", pset_name, this->is.port.name, size 
    ) ;
  
    if( JL_vpi_mode ) {
      VOUT9( 
        "  $JEDA_vpi_task( %d, \"%s\", \"%s\", %d, %d, jeda_in_%s_%s, jeda_out_%s_%s  ) ;\n", 
        JEDA_LINK_PSET_PORT, pset_name, this->is.port.name, 
        this->index, dir, pset_name, 
        this->is.port.name, pset_name, this->is.port.name
      ) ;
    }
    else {
      VOUT9( 
        "  $JEDA_task( %d, \"%s\", \"%s\", %d, %d, jeda_in_%s_%s, jeda_out_%s_%s  ) ;\n", 
        JEDA_LINK_PSET_PORT, pset_name, this->is.port.name, 
        this->index, dir, pset_name, 
        this->is.port.name, pset_name, this->is.port.name
      ) ;
    }
    this = this->next ;
  }
}  

static void out_var_link( vcode_info *this ) {  
  vcode_info *attrib ;
  char *nm ;
  vcode_info *array_range ;
  int dtype ;
  int i ;
  
  nm = this->is.variable_dcl.name ;
  dtype = this->is.variable_dcl.data_type->is.data_type.type ;
  attrib = this->is.variable_dcl.var_attrib ;

  if( attrib && attrib->is.attrib.is_local ) return ; /* no output on local */
    
  array_range = this->is.variable_dcl.array_range ;
  
  switch( array_range->is.array_range.type ) {
    case VI_single:
      switch( dtype ) {
        case VI_int:
        case VI_bit:
          if( JL_vpi_mode ) {
            VOUT4( 
              "  $JEDA_vpi_task( %d, \"%s\", %d, var_%s ) ;\n", 
              JEDA_LINK_GLOBAL_VAR, nm, this->index, nm
            ) ;
          }
          else {
            VOUT4( 
              "  $JEDA_task( %d, \"%s\", %d, var_%s ) ;\n", 
              JEDA_LINK_GLOBAL_VAR, nm, this->index, nm
            ) ;
          }
          break ;
      }
      break ;
    case VI_array:
      switch( dtype ) {
        case VI_int:
        case VI_bit:
          for( i = 0 ; i < array_range->is.array_range.size ; i++ ) {
            if( JL_vpi_mode ) {
              VOUT7( 
                "  $JEDA_vpi_task( %d, \"%s\", %d, var_%s[%d], %d, %d ) ;\n", 
                JEDA_LINK_GLOBAL_VAR_ARRAY, nm, this->index, nm, i, i,
                array_range->is.array_range.size
              ) ;
            }
            else {
              VOUT7( 
                "  $JEDA_task( %d, \"%s\", %d, var_%s[%d], %d, %d ) ;\n", 
                JEDA_LINK_GLOBAL_VAR_ARRAY, nm, this->index, nm, i, i,
                array_range->is.array_range.size
              ) ;
            }
          }
          break ;
      }
      break ;
  }
  
}

static void out_static_var_link( vcode_info *this ) {  
  vcode_info *attrib ;
  vcode_info *array_range ;
  int dtype ;
  char *cls, *fnc, *nm ;
  int i ;
  
  cls = this->is.static_var_dcl.class ;
  if( !strcmp(cls, "null") ) cls = "" ;
  fnc = this->is.static_var_dcl.func ;
  if( !strcmp(fnc, "null") ) fnc = "" ;
  nm = this->is.static_var_dcl.name ;
  
  dtype = this->is.static_var_dcl.data_type->is.data_type.type ;
  attrib = this->is.static_var_dcl.attribs ;

  if( attrib && attrib->is.attrib.is_local ) return ; /* no output on local */

  array_range = this->is.static_var_dcl.array_range ;
  
  switch( array_range->is.array_range.type ) {
    case VI_single:
      switch( dtype ) {
        case VI_int:
        case VI_bit:
          if( JL_vpi_mode ) {
            VOUT8( 
              "  $JEDA_pli_task( %d, \"%s\", \"%s\", \"%s\", %d, svar_%s_%s_%s ) ;\n", 
              JEDA_LINK_STATIC_VAR, cls, fnc, nm, this->index, cls, fnc, nm
            ) ;
          }
          else {
            VOUT8( 
              "  $JEDA_task( %d, \"%s\", \"%s\", \"%s\", %d, svar_%s_%s_%s ) ;\n", 
              JEDA_LINK_STATIC_VAR, cls, fnc, nm, this->index, cls, fnc, nm
            ) ;
          }
          break ;
      }
      break ;
    case VI_array:
      switch( dtype ) {
        case VI_int:
        case VI_bit:
          for( i = 0 ; i < array_range->is.array_range.size ; i++ ) {
            if( JL_vpi_mode ) {
              VOUT11( 
                "  $JEDA_vpi_task( %d, \"%s\", \"%s\", \"%s\", %d, svar_%s_%s_%s[%d], %d, %d ) ;\n", 
                JEDA_LINK_STATIC_VAR_ARRAY, cls, fnc, nm, this->index, 
                cls, fnc, nm, i, i, array_range->is.array_range.size
              ) ;
            }
            else {
              VOUT11( 
                "  $JEDA_task( %d, \"%s\", \"%s\", \"%s\", %d, svar_%s_%s_%s[%d], %d, %d ) ;\n", 
                JEDA_LINK_STATIC_VAR_ARRAY, cls, fnc, nm, this->index, 
                cls, fnc, nm, i, i, array_range->is.array_range.size
              ) ;
            }
          }
          break ;
      }
      break ;
  
  }

}

static void out_veri_task_link( vcode_info *this ) {  
  vcode_info *arg ;
  char *nm, *anm ;
  int narg ;
  narg = 0 ;
  
  arg = this->is.function_info.arguments ;
  while(arg) {
    narg++ ;
    arg = arg->next ;
  }
  
  arg = this->is.function_info.arguments ;
  nm = this->is.function_info.name ;
  
  if( JL_vpi_mode ) {
    VOUT6(  
      "  $JEDA_vpi_task( %d, \"%s\", %d, veri_task_%s_call, veri_task_%s_done, %d", 
      JEDA_LINK_VERI_TASK, nm, this->index, nm, nm, narg
    ) ;
  }
  else {
    VOUT6(  
      "  $JEDA_task( %d, \"%s\", %d, veri_task_%s_call, veri_task_%s_done, %d", 
      JEDA_LINK_VERI_TASK, nm, this->index, nm, nm, narg
    ) ;
  }
  
  while( arg ) {
    anm = arg->is.argument.name ;
    VOUT2( ", arg_%s_%s \n", nm, anm ) ;
    arg = arg->next ;
  }

  VOUT0( " ) ;\n" ) ;
  
}


/***************************************************************************/
/*  Verilog Top File generation                                            */
/***************************************************************************/

static void out_top_header() {
  VOUT0( 
    "/**********************************************************************\n"
  );
  VOUT0(
    "*  JEDA verilog top_module created by JEDA linker\n"
  );
  VOUT0(
    "*    WARNING: This file may be overwritten by linker.\n"
  );
  VOUT0(
    "*      Copy this to different file if you want to modify manually.\n"
  );
  VOUT0( 
    "**********************************************************************/\n"
  );
}

static void out_port_wire_dcl() {
  vcode_info *this, *pt ;
  char *pset_name ;
  
  this = JD_top_inst ;
  
  /* output port list */
  while( this ) {
    switch( this->type ) {
      case JD_port_info:
        if( get_connection_attrib(this) == NULL ) {
          VOUT0( "  wire" ) ;
          if( this->is.port.ub || this->is.port.lb ) {
            VOUT2( " [%d:%d]", this->is.port.ub, this->is.port.lb ) ;
          }
          VOUT1( " %s ;\n", this->is.port.name ) ;
        }
        break ;
      case JD_portset_info:
        pset_name = this->is.portset.name ;
        pt = this->is.portset.port_infos ;
        while( pt ) {
          if( pt->type == JD_port_info ) {
            if( get_connection_attrib(pt) == NULL ) {
              VOUT0( "  wire" ) ;
              if( pt->is.port.ub || pt->is.port.lb ) {
                VOUT2( " [%d:%d]", pt->is.port.ub, pt->is.port.lb ) ;
              }
              VOUT2( "  %s_%s ;\n", pset_name, pt->is.port.name ) ;
            }
          }
          pt = pt->next ;
        }
        break ;
      default:
        break ;
    }
    this = this->next ;
  }

}

static void out_port_wire_connection_dcl() {
  vcode_info *this, *pt ;
  char *pset_name ;
  
  
  VOUT0( "    .CLOCK(CLOCK)" ) ;
  this = JD_top_inst ;

  this = JD_top_inst ;
  
  /* output port list */
  while( this ) {
    switch( this->type ) {
      case JD_port_info:
        if( get_connection_attrib(this) == NULL ) {
          VOUT0( ",\n    ." ) ;
          VOUT2( "%s(%s)", this->is.port.name, this->is.port.name ) ;
        }
        break ;
      case JD_portset_info:
        pset_name = this->is.portset.name ;
        pt = this->is.portset.port_infos ;
        while( pt ) {
          if( pt->type == JD_port_info ) {
            if( get_connection_attrib(pt) == NULL ) {
              VOUT0( ",\n    ." ) ;
              VOUT4( 
                "%s_%s(%s_%s)",
                pset_name, pt->is.port.name, pset_name, pt->is.port.name 
              ) ;
            }
          }
          pt = pt->next ;
        }
        break ;
      default:
        break ;
    }
    this = this->next ;
  }

}


/********************************************************************/
/* Standalone Link generation                                       */
/********************************************************************/
static void out_standalone_port_link( vcode_info *this ) {  
  int size, dir ;
  /* connecting verilog structure to Jeda */
  switch( this->is.port.direction ) {
    case VI_input: dir = JEDA_INPUT ; break ;
    case VI_output: dir = JEDA_OUTPUT ; break ;
    case VI_inout: dir = JEDA_INOUT ; break ;
  }
  
  if( this->is.port.ub > this->is.port.lb ) 
    size = this->is.port.ub - this->is.port.lb + 1 ;
  else 
    size = this->is.port.lb - this->is.port.ub + 1 ;
    
  OUT5( 
    "  JD_standalone_port_link( \"%s\", %d, %d, %d, %d ) ;\n", 
    this->is.port.name, 
    this->index, dir,
    get_sample_skew(this),
    get_drive_skew(this)
  ) ;
  
}  

static void out_standalone_portset_link( vcode_info *pset ) {  
  int size, dir ;
  vcode_info *this ;
  char *pset_name ;
  /* connecting verilog structure to Jeda */
  
  pset_name = pset->is.portset.name ;
  this = pset->is.portset.port_infos ;

  while( this ) {
    switch( this->is.port.direction ) {
      case VI_input: dir = JEDA_INPUT ; break ;
      case VI_output: dir = JEDA_OUTPUT ; break ;
      case VI_inout: dir = JEDA_INOUT ; break ;
    }
  
    if( this->is.port.ub > this->is.port.lb ) 
      size = this->is.port.ub - this->is.port.lb + 1 ;
    else 
      size = this->is.port.lb - this->is.port.ub + 1 ;
    
    OUT6( 
      "  JD_standalone_portset_link( \"%s\", \"%s\", %d, %d, %d, %d  ) ;\n", 
      pset_name, this->is.port.name, 
      this->index, dir,
      get_sample_skew(this),
      get_drive_skew(this)
    ) ;
    this = this->next ;
  }
}  

static void out_standalone_var_link( vcode_info *this ) {  
  vcode_info *attrib ;
  char *nm ;
  vcode_info *array_range, *data_type ;
  int dtype ;
  int i ;
  int size ;
  
  nm = this->is.variable_dcl.name ;
  dtype = this->is.variable_dcl.data_type->is.data_type.type ;
  attrib = this->is.variable_dcl.var_attrib ;
  data_type = this->is.variable_dcl.data_type ;

  if( attrib && attrib->is.attrib.is_local ) return ; /* no output on local */
    
  array_range = this->is.variable_dcl.array_range ;
  
  switch( array_range->is.array_range.type ) {
    case VI_single:
      switch( dtype ) {
        case VI_int:
          OUT2( 
            "  JD_standalone_global_var_link( \"%s\", %d, 32 ) ;\n", 
            nm, this->index
          ) ;
          break ;
        case VI_bit:
          if( data_type->is.data_type.ub > data_type->is.data_type.lb ) 
            size = data_type->is.data_type.ub - data_type->is.data_type.lb + 1 ;
          else 
            size = data_type->is.data_type.lb - data_type->is.data_type.ub + 1 ;
          OUT3( 
            "  JD_standalone_global_var_link( \"%s\", %d, %d ) ;\n", 
            nm, this->index, size
          ) ;
          break ;
      }
      break ;
    case VI_array:
      switch( dtype ) {
        case VI_int:
        case VI_bit:
          for( i = 0 ; i < array_range->is.array_range.size ; i++ ) {
            OUT4( 
              "  JD_standalone_global_var_array_link( \"%s\", %d, %d, %d ) ;\n", 
              nm, this->index, i,
              array_range->is.array_range.size
            ) ;
          }
          break ;
          
      }
      break ;
  }
  
}

static void out_standalone_static_var_link( vcode_info *this ) {  
  vcode_info *attrib ;
  vcode_info *array_range, *data_type ;
  int dtype ;
  char *cls, *fnc, *nm ;
  int i ;
  int size ;
  
  cls = this->is.static_var_dcl.class ;
  if( !strcmp(cls, "null") ) cls = "" ;
  fnc = this->is.static_var_dcl.func ;
  if( !strcmp(fnc, "null") ) fnc = "" ;
  nm = this->is.static_var_dcl.name ;
  
  
  dtype = this->is.static_var_dcl.data_type->is.data_type.type ;
  attrib = this->is.static_var_dcl.attribs ;
  data_type = this->is.static_var_dcl.data_type ;

  if( attrib && attrib->is.attrib.is_local ) return ; /* no output on local */

  array_range = this->is.static_var_dcl.array_range ;
  
  switch( array_range->is.array_range.type ) {
    case VI_single:
      switch( dtype ) {
        case VI_int:
          OUT4( 
            "  JD_standalone_static_var_link( \"%s\", \"%s\", \"%s\", %d, 32 ) ;\n", 
            cls, fnc, nm, this->index
          ) ;
          break ;
        case VI_bit:
          if( data_type->is.data_type.ub > data_type->is.data_type.lb ) 
            size = data_type->is.data_type.ub - data_type->is.data_type.lb + 1 ;
          else 
            size = data_type->is.data_type.lb - data_type->is.data_type.ub + 1 ;
          OUT5( 
            "  JD_standalone_static_var_link( \"%s\", \"%s\", \"%s\", %d ) ;\n", 
            cls, fnc, nm, this->index, size
          ) ;
          break ;
      }
      break ;
    case VI_array:
      switch( dtype ) {
        case VI_int:
        case VI_bit:
          for( i = 0 ; i < array_range->is.array_range.size ; i++ ) {
            OUT6( 
              "  JD_standalone_static_var_array_link( \"%s\", \"%s\", \"%s\", %d, %d, %d ) ;\n", 
              cls, fnc, nm, this->index, 
              i, array_range->is.array_range.size
            ) ;
          }
          break ;
      }
      break ;
  
  }

}

static void out_standalone_veri_task_link( vcode_info *this ) {  
  vcode_info *arg ;
  char *nm, *anm ;
  int narg ;
  narg = 0 ;
  
  arg = this->is.function_info.arguments ;
  while(arg) {
    narg++ ;
    arg = arg->next ;
  }
  
  arg = this->is.function_info.arguments ;
  nm = this->is.function_info.name ;
  
  OUT3(  
    "  JD_standalone_veri_task_link( \"%s\", %d,  %d ) ;\n", 
    nm, this->index, narg
  ) ;

  
}




/********************************************************************/

static void verilog_top_gen() {
  vout = fopen( out_vtop_fname, "w" ) ;
  if( vout == NULL ) {
    fprintf( 
      stderr, "Error: Can't open Jeda verilog top file \"%s\"\n", 
      out_vtop_fname 
    ) ;
    exit(1) ;
  }

  out_top_header() ;
  
  VOUT1( "module %s_top_module () ;\n", out_fname ) ;
  VOUT0( "  parameter SimulationCycle = 80 ;\n" ) ;

  VOUT0( "\n" ) ;
  
  VOUT0( "  reg CLOCK_reg ;\n" ) ;
  VOUT0( "  wire CLOCK = CLOCK_reg ;\n" ) ;

  out_port_wire_dcl() ;  
  
  VOUT0( "\n" ) ;
  VOUT0( "  jeda_module jeda (\n" ) ;
  
  out_port_wire_connection_dcl() ;
  
  VOUT0( "\n" ) ;
  VOUT0( "  );\n" ) ;

  VOUT0( "\n" ) ;
  VOUT0( "\n  // Place your DUT(s) here.\n" ) ;
  VOUT0( "\n" ) ;
  
  VOUT0( "  initial begin \n" ) ;
  VOUT0( "    CLOCK_reg = 0 ;\n" ) ;
  VOUT0( "    forever begin\n" ) ;
  VOUT0( "      #(SimulationCycle/2) CLOCK_reg = ~CLOCK_reg ;\n" ) ;
  VOUT0( "    end\n" ) ;
  VOUT0( "  end\n" ) ;
  
  VOUT0( "\n" ) ;
  VOUT0( "endmodule\n" ) ;

  close( vout ) ;
  
}

void vmodule_gen() {
  vcode_info *this ;
  vcode_info *attrib ;
  int vcall_id = 0 ;
  vout = fopen( out_v_fname, "w" ) ;
  if( vout == NULL ) {
    fprintf( 
      stderr, "Error: Can't open Jeda module verilog output file \"%s\"\n", 
      out_v_fname 
    ) ;
    exit(1) ;
  }
  
  hash_value = 0 ;
  
  resolve_connection() ;
  
  out_header() ;
  
  /* VOUT1( "module %s_module (\n", out_fname ) ; */
  VOUT0( "module jeda_module (\n" ) ;
  
  out_port_list() ;
  
  VOUT0( "\n" ) ;
  VOUT0( ");\n" ) ;

  out_port_dcl() ;  
  
  out_port_connection_dcl() ;
  
  
  VOUT0( "  reg [31:0] CycleCount ;\n" ) ;
  VOUT0( "  initial CycleCount = 0 ;\n" ) ;
  VOUT0( "  always @(posedge CLOCK) CycleCount = CycleCount+1 ;\n" ) ;
  
  /* output other structures */
  this = JD_top_inst ;
  
  while( this ) {
    switch( this->type ) {
      case JD_variable_dcl:
        out_var_dcl(this) ;
        break ;
      case JD_veri_task_info:
        out_veri_task_dcl(this) ;
        break ;
      case JD_function_info:
        attrib = this->is.function_info.func_options ;
        if( attrib && attrib->is.attrib.is_export ) {
          out_jeda_task_dcl(this, vcall_id++) ;
        }
        break ;
      case JD_static_var_info:
        out_static_var_dcl(this) ;
        break ;
      default:
        break ;
    }
    this = this->next ;
  }

  /* initial block */
  VOUT0( "  initial begin // Jeda initialization\n" ) ;
  last_hash_value = hash_value ;
  if( JL_vpi_mode ) {
    VOUT3( 
      "  $JEDA_vpi_task( %d, \"%s\", %d ) ; // Jeda init \n",
      JEDA_INIT, out_fname, last_hash_value
    ) ;
  }
  else {
    VOUT3( 
      "  $JEDA_task( %d, \"%s\", %d ) ; // Jeda init \n",
      JEDA_INIT, out_fname, last_hash_value 
    ) ;
  }
  
  VOUT0( "  jeda_out_CLOCK = 1'bz ;\n" ) ;
  if( JL_vpi_mode ) {
    VOUT1( 
      "  $JEDA_vpi_task( %d, jeda_in_CLOCK, jeda_out_CLOCK, CycleCount ) ;\n", 
      JEDA_CLOCK
    ) ; 
  }
  else {
    VOUT1( 
      "  $JEDA_task( %d, jeda_in_CLOCK, jeda_out_CLOCK, CycleCount ) ;\n", 
      JEDA_CLOCK
    ) ; 
  }
  
  this = JD_top_inst ;
  while( this ) {
    if( this->type == JD_port_info ) {
      out_port_link( this ) ;
    }
    this = this->next ;
  }
  this = JD_top_inst ;
  while( this ) {
    if( this->type == JD_portset_info ) {
      out_portset_link( this ) ;
    }
    this = this->next ;
  }
  this = JD_top_inst ;
  while( this ) {
    if( this->type == JD_veri_task_info ) {
      out_veri_task_link( this ) ;
    }
    this = this->next ;
  }
  this = JD_top_inst ;
  while( this ) {
    if( this->type == JD_variable_dcl ) {
      out_var_link( this ) ;
    }
    this = this->next ;
  }
  this = JD_top_inst ;
  while( this ) {
    if( this->type == JD_static_var_info ) {
      out_static_var_link( this ) ;
    }
    this = this->next ;
  }
   
  /* invoke the Jeda initializer and start the 'main' code */
  if( JL_vpi_mode ) {
    VOUT1( 
      "  $JEDA_vpi_task( %d ) ; // Jeda link_gen_main \n",
      JEDA_LINK_CREATE_MAIN
    ) ;
  }
  else {
    VOUT1( 
      "  $JEDA_task( %d ) ; // Jeda link_gen_main \n",
      JEDA_LINK_CREATE_MAIN
    ) ;
  }
  
  VOUT0( "  end // end of Jeda initilization\n" ) ;
  VOUT0( "endmodule\n" ) ;
  close( vout ) ;

  if( JL_verilog_top_mode ) {
    verilog_top_gen() ;
  }
  
  /* standalone link function generation */
  
  if( JL_standalone_mode ) {
    OUT0( "void JD_standalone_link() {\n" ) ;
    
    OUT0( "  JD_standalone_link_CLOCK() ;\n" ) ;
    this = JD_top_inst ;
  
    while( this ) {
      switch( this->type ) {
        case JD_port_info:
          out_standalone_port_link( this ) ;
          break ;
        case JD_portset_info:
          out_standalone_portset_link( this ) ;
          break ;
        case JD_variable_dcl:
          out_standalone_var_link( this ) ;
          break ;
        case JD_veri_task_info:
          out_standalone_veri_task_link( this ) ;
          break ;
        case JD_static_var_info:
          out_standalone_static_var_link( this ) ;
          break ;
        default:
          break ;
      }
      this = this->next ;
    }
    OUT0( "}\n" ) ;
  
  }
  
}

int get_vcode_hash_value() {
  return last_hash_value ;
}

void out_port_alloc( vcode_info *this )
{
  int dir, depth, s_edge, d_edge, clk_index ;
  vcode_info *clk_attr, *clk ;
  JD_name *pset, *prt ;
  
  switch( this->is.port.direction ) {
    case VI_input: dir = JEDA_INPUT ; break ;
    case VI_output: dir = JEDA_OUTPUT ; break ;
    case VI_inout: dir = JEDA_INOUT ; break ;
  }
  
  switch( get_drive_edge( this ) ) {
    case VI_posedge: d_edge = JEDA_POSEDGE ; break ;
    case VI_negedge: d_edge = JEDA_NEGEDGE ; break ;
    case VI_bothedge: d_edge = JEDA_BOTHEDGE ; break ;
    default: d_edge = JEDA_POSEDGE ; break ;
  }
  
  switch( get_sample_edge( this ) ) {
    case VI_posedge: s_edge = JEDA_POSEDGE ; break ;
    case VI_negedge: s_edge = JEDA_NEGEDGE ; break ;
    case VI_bothedge: s_edge = JEDA_BOTHEDGE ; break ;
    default: s_edge = JEDA_POSEDGE ; break ;
  }
  
  clk_attr = get_clock_attrib(this) ;
  
  depth = get_depth(this) ;
  
  if( clk_attr && strcmp(clk_attr->is.port_clock_attrib.port,"CLOCK") ) {
    if( clk_attr->is.port_clock_attrib.pset == NULL ) {
      prt = find_global_name( clk_attr->is.port_clock_attrib.port ) ;
      if( !prt ) {
        fprintf( 
          stderr, "Fatal, port name %s can't be found\n", 
          clk_attr->is.port_clock_attrib.port
        ) ;
        exit(1) ;
      }
      clk = prt->info ;
    }
    else {
      pset = find_global_name( clk_attr->is.port_clock_attrib.pset ) ;
      if( !pset ) {
        fprintf( 
          stderr, "Fatal, portset name %s can't be found\n", 
          clk_attr->is.port_clock_attrib.pset
        ) ;
        exit(1) ;
      }
      prt =
        find_name_in_scope(clk_attr->is.port_clock_attrib.port, pset->child) ;
      if( !prt ) {
        fprintf( 
          stderr, "Fatal, port name %s can't be found in portset %s\n", 
          clk_attr->is.port_clock_attrib.port, 
          clk_attr->is.port_clock_attrib.pset
        ) ;
        exit(1) ;
      }
      clk = prt->info ;
    }
    clk_index = clk->index ;
  }
  else {
    clk_index = 0 ;
  }
  
  OUT9( 
    "JD_alloc_port( \"%s\", %d, %d, %d, %d, %d, %d, %d, %d ) ;\n",
    this->is.port.name, this->is.port.ub, this->is.port.lb,
    this->index, dir, s_edge, depth, d_edge, clk_index
  );
  
}

void out_portset_alloc( vcode_info *port_set, int *gindex )
{
  int dir, depth, s_edge, d_edge, clk_index ;
  vcode_info *clk_attr, *clk ;
  char *pset_name ;
  JD_name *pset, *prt ;
  vcode_info *this ;
  
  pset_name = port_set->is.portset.name ;
  this = port_set->is.portset.port_infos ;

  while( this ) {
    switch( this->is.port.direction ) {
      case VI_input: dir = JEDA_INPUT ; break ;
      case VI_output: dir = JEDA_OUTPUT ; break ;
      case VI_inout: dir = JEDA_INOUT ; break ;
    }
  
    switch( get_drive_edge( this ) ) {
      case VI_posedge: d_edge = JEDA_POSEDGE ; break ;
      case VI_negedge: d_edge = JEDA_NEGEDGE ; break ;
      case VI_bothedge: d_edge = JEDA_BOTHEDGE ; break ;
      default: d_edge = JEDA_POSEDGE ; break ;
    }
  
    switch( get_sample_edge( this ) ) {
      case VI_posedge: s_edge = JEDA_POSEDGE ; break ;
      case VI_negedge: s_edge = JEDA_NEGEDGE ; break ;
      case VI_bothedge: s_edge = JEDA_BOTHEDGE ; break ;
      default: s_edge = JEDA_POSEDGE ; break ;
    }
  
    clk_attr = get_clock_attrib(this) ;
  
    depth = get_depth(this) ;
  
  if( clk_attr && strcmp(clk_attr->is.port_clock_attrib.port,"CLOCK") ) {
      if( clk_attr->is.port_clock_attrib.pset == NULL ) {
        prt = find_global_name( clk_attr->is.port_clock_attrib.port ) ;
        if( !prt ) {
          fprintf( 
            stderr, "Fatal, port name %s can't be found\n", 
            clk_attr->is.port_clock_attrib.port
          ) ;
          exit(1) ;
        }
        clk = prt->info ;
      }
      else {
        pset = find_global_name( clk_attr->is.port_clock_attrib.pset ) ;
        if( !pset ) {
          fprintf( 
            stderr, "Fatal, portset name %s can't be found\n", 
            clk_attr->is.port_clock_attrib.pset
          ) ;
          exit(1) ;
        }
        prt =
          find_name_in_scope(clk_attr->is.port_clock_attrib.port, pset->child) ;
        if( !prt ) {
          fprintf( 
            stderr, "Fatal, port name %s can't be found in portset %s\n", 
            clk_attr->is.port_clock_attrib.port, 
            clk_attr->is.port_clock_attrib.pset
          ) ;
          exit(1) ;
        }
        clk = prt->info ;
      }
      clk_index = clk->index ;
    }
    else {
      clk_index = 0 ;
    }
  
    OUT10( 
      "JD_alloc_pset_port( \"%s\", \"%s\", %d, %d, %d, %d, %d, %d, %d, %d ) ;\n",
      pset_name, this->is.port.name, 
      this->is.port.ub, this->is.port.lb,
      this->index, dir, s_edge, depth, d_edge, clk_index
    );
    OUT0( "top->num_global_data++ ;\n" ) ;
    *gindex = *gindex + 1 ;
    this = this->next ;
  } /* end of while( this ) */
}



