/********************************************/
/* macro generated by gen_code_out_macro_prod.pl */
/********************************************/
#  define CALL_EXEC_COPY_DT(dt,x)  JD_copy_dt(dt,x)
#define OUT_EXEC_COPY_DT(dt,x) \
    OUT0( "JD_copy_dt(dt,x) ;\n" ) ; 
#  define CALL_EXEC_SET_DT(dt,x)  JD_set_dt(dt,x)
#define OUT_EXEC_SET_DT(dt,x) \
    OUT0( "JD_set_dt(dt,x) ;\n" ) ; 
#  define CALL_EXEC_PUSH_VSTACK  JD_push_vstack()
#define OUT_EXEC_PUSH_VSTACK \
    OUT0( "JD_push_vstack() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_PUSH_ACC  { \
   {\
     JD_data *dt ;\
     if(VSP==VSP_LIMIT) {  /* vstack full, flush one entry */\
       if( FITSMLINT(VSTACK[VS_TOP]) ) {\
         dt = GENSMLINT(VSTACK[VS_TOP]) ;\
 \
       }\
       else {\
         dt = JD_alloc_data_entry() ;\
         JD_copy_dt( dt, VSTACK[VS_TOP] ) ;\
 \
 \
       }\
       PUSH_TO_STACK(dt) ;\
       VSP-- ;\
     }\
     dt = VSTACK[VS_TOP] ;\
     dt->data.list.top = NULL ;\
     dt->data.list.bottom = NULL ;\
     dt->data.list.sem = NULL ;\
     dt->base = NULL ;\
 \
     switch(ACC_TYPE) {\
       case JD_D_sbit:\
       case JD_D_vbit:\
       case JD_D_bit:\
         dt->sub_type = JD_SD_single ;\
         if( ACC_SIZE <= 32 ) {\
           dt->type = JD_D_sbit ;\
           dt->data.sbit.a = ACC_A[0] ;\
           dt->data.sbit.b = ACC_B[0] ;\
           dt->data.sbit.size = ACC_SIZE ;\
         }\
         else {\
           int i, n ;\
           unsigned int *taba, *tabb ;\
           dt->type = JD_D_vbit ;\
           n = NWORD(ACC_SIZE) ;\
           if( n > VS_WD[VS_TOP] ) {\
             VS_A[VS_TOP] = \
               (unsigned int *)realloc( VS_A[VS_TOP], NBYTE(ACC_SIZE) ) ;\
             VS_B[VS_TOP] = \
               (unsigned int *)realloc( VS_B[VS_TOP], NBYTE(ACC_SIZE) ) ;\
             VS_WD[VS_TOP] = n ;\
           }\
           taba = VS_A[VS_TOP] ;\
           tabb = VS_B[VS_TOP] ;\
           for( i = 0 ; i < n ; i++ ) {\
             taba[i] = ACC_A[i] ;\
             tabb[i] = ACC_B[i] ;\
           }\
           dt->data.bit.a = (int *)VS_A[VS_TOP] ;\
           dt->data.bit.b = (int *)VS_B[VS_TOP] ;\
           dt->data.bit.size = ACC_SIZE ;\
         }\
         break ;\
       case JD_D_int:\
         dt->sub_type = JD_SD_single ;\
         dt->type = JD_D_int ;\
         dt->data.int_value = ACC_INT ;\
         break ;\
       case JD_D_float:\
         dt->sub_type = JD_SD_single ;\
         dt->type = JD_D_float ;\
         dt->data.float_value = ACC_FLOAT ;\
         break ;\
       case JD_D_double:\
         dt->sub_type = JD_SD_single ;\
         dt->type = JD_D_double ;\
         dt->data.double_value = ACC_FLOAT ;\
         break ;\
       case JD_D_string:\
         dt->sub_type = JD_SD_single ;\
         dt->type = JD_D_string ;\
         dt->data.string = ACC_STRING ;\
         ACC_STRING = NULL ;\
         ACC_TYPE = JD_D_void ;\
         break ;\
       case JD_D_dt:\
         if( ACC_DT ) {\
           JD_set_dt( dt, ACC_DT ) ;\
           ACC_DT = NULL ;\
           ACC_TYPE = JD_D_null ;\
         }\
         else {\
           dt->type = JD_D_null ;\
           dt->sub_type = JD_SD_single ;\
           ACC_TYPE = JD_D_null ;\
         }\
         break ;\
       case JD_D_null:\
         dt->type = JD_D_null ;\
         dt->sub_type = JD_SD_single ;\
         break ;\
       default:\
         dt->type = JD_D_null ;\
         dt->sub_type = JD_SD_single ;\
         break ;\
     }\
     \
     VS_TOP = (VS_TOP+1) % VSP_LIMIT ;\
     VSP++ ;\
   }\
  }
#else
#  define CALL_EXEC_PUSH_ACC  JD_push_acc()
#endif
#define OUT_EXEC_PUSH_ACC \
    OUT0( "JD_push_acc() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_FLUSH_VSTACK  { \
   {\
     JD_data *dt, *st ;\
     while(VSP) {\
       if( VS_TOP < VSP ) {\
         st = VSTACK[VSP_LIMIT+VS_TOP-VSP] ;\
       }\
       else {\
         st = VSTACK[VS_TOP-VSP] ;\
       }\
       if( FITSMLINT(st) ) {\
         dt = GENSMLINT(st) ;\
 \
       }\
       else {\
         dt = JD_alloc_data_entry() ;\
         JD_copy_dt( dt, st ) ;\
         st->sub_type = JD_SD_single ;\
 \
       }\
       PUSH_TO_STACK(dt) ;\
       VSP-- ;\
     }\
   }\
  }
#else
#  define CALL_EXEC_FLUSH_VSTACK  JD_flush_vstack()
#endif
#define OUT_EXEC_FLUSH_VSTACK \
  if( inline_optimization > 1 ) {  \
    OUT0( "    /* Macro for JD_flush_vstack */ \n" ) ; \
    OUT0( "  {\n" ) ;\
    OUT0( "    JD_data *dt, *st ;\n" ) ;\
    OUT0( "    while(VSP) {\n" ) ;\
    OUT0( "      if( VS_TOP < VSP ) {\n" ) ;\
    OUT0( "        st = VSTACK[VSP_LIMIT+VS_TOP-VSP] ;\n" ) ;\
    OUT0( "      }\n" ) ;\
    OUT0( "      else {\n" ) ;\
    OUT0( "        st = VSTACK[VS_TOP-VSP] ;\n" ) ;\
    OUT0( "      }\n" ) ;\
    OUT0( "      if( FITSMLINT(st) ) {\n" ) ;\
    OUT0( "        dt = GENSMLINT(st) ;\n" ) ;\
    OUT0( "\n" ) ;\
    OUT0( "      }\n" ) ;\
    OUT0( "      else {\n" ) ;\
    OUT0( "        dt = JD_alloc_data_entry() ;\n" ) ;\
    OUT0( "        JD_copy_dt( dt, st ) ;\n" ) ;\
    OUT0( "        st->sub_type = JD_SD_single ;\n" ) ;\
    OUT0( "\n" ) ;\
    OUT0( "      }\n" ) ;\
    OUT0( "      PUSH_TO_STACK(dt) ;\n" ) ;\
    OUT0( "      VSP-- ;\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_flush_vstack() ;\n" ) ; \
  }
#  define CALL_EXEC_SET_ACC(x)  JD_set_acc(x)
#define OUT_EXEC_SET_ACC(x) \
    OUT0( "JD_set_acc(x) ;\n" ) ; 
#  define CALL_EXEC_COPY_ACC(x)  JD_copy_acc(x)
#define OUT_EXEC_COPY_ACC(x) \
    OUT0( "JD_copy_acc(x) ;\n" ) ; 
#  define CALL_EXEC_ACC_TO_DT(x)  JD_acc_to_dt(x)
#define OUT_EXEC_ACC_TO_DT(x) \
    OUT0( "JD_acc_to_dt(x) ;\n" ) ; 
#  define CALL_EXEC_SET_ACC_TO_DT(x)  JD_set_acc_to_dt(x)
#define OUT_EXEC_SET_ACC_TO_DT(x) \
    OUT0( "JD_set_acc_to_dt(x) ;\n" ) ; 
#  define CALL_EXEC_NULL_ACC(dt)  JD_null_acc(dt)
#define OUT_EXEC_NULL_ACC(dt) \
    OUT0( "JD_null_acc(dt) ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_POP_ACC  { \
   {  \
     JD_data *dt ;\
     if( VSP ) {\
       if( VS_TOP ) VS_TOP-- ;\
       else VS_TOP = VSP_LIMIT-1 ;\
       VSP-- ;\
       dt = VSTACK[VS_TOP] ;\
 \
       if( ACC_TYPE == JD_D_string && ACC_STRING != NULL ) {\
         DEALLOC_STRING(ACC_STRING) ;\
         ACC_STRING = NULL ;\
       }\
       if( dt->sub_type == JD_SD_single ) {\
         ACC_TYPE = dt->type ;\
         switch(ACC_TYPE) {\
           case JD_D_sbit:\
             ACC_SIZE = dt->data.sbit.size ;\
             ACC_A[0] = dt->data.sbit.a ;\
             ACC_B[0] = dt->data.sbit.b ;\
             ACC_TYPE = JD_D_bit ;\
             break ;\
           case JD_D_vbit:\
           case JD_D_bit:\
             {\
               int tmp ;\
               unsigned int *tab ;\
               tab = VS_A[VS_TOP] ;\
               VS_A[VS_TOP] = ACC_A ;\
               ACC_A = tab ;\
               tab = VS_B[VS_TOP] ;\
               VS_B[VS_TOP] = ACC_B ;\
               ACC_B = tab ;\
               tmp = VS_WD[VS_TOP] ;\
               VS_WD[VS_TOP] = ACC_WD ;\
               ACC_WD = tmp ;\
               ACC_TYPE = JD_D_bit ;\
             }\
             dt->type = JD_D_int ;\
             dt->data.list.top = NULL ;\
             dt->data.list.bottom = NULL ;\
             dt->data.list.sem = NULL ;\
             dt->base = NULL ;\
             break ;\
           case JD_D_int:\
             ACC_INT = dt->data.int_value ;\
             break ;\
           case JD_D_float:\
             ACC_FLOAT = dt->data.float_value ;\
             break ;\
           case JD_D_double:\
             ACC_FLOAT = dt->data.double_value ;\
             break ;\
           case JD_D_string:\
             ACC_STRING = dt->data.string ;\
             dt->type = JD_D_int ;\
             dt->data.list.top = NULL ;\
             dt->data.list.bottom = NULL ;\
             dt->data.list.sem = NULL ;\
             dt->base = NULL ;\
             break ;\
           case JD_D_null:\
             break ;\
           default:\
             ACC_TYPE = JD_D_dt ;\
             ACC_DT = dt ;\
 \
             VSTACK[VS_TOP] = JD_alloc_data_entry() ;\
             break ;\
         }\
       }\
       else {\
         ACC_TYPE = JD_D_dt ;\
         ACC_DT = dt ;\
         VSTACK[VS_TOP] = JD_alloc_data_entry() ;\
 \
       }\
     }\
     else {\
       dt = STACK[--SP] ;\
 \
       if( IS_SMLINT(dt) ) {\
         ACC_INT = SMLINT2INT(dt) ;\
         ACC_TYPE = JD_D_int ;\
       }\
       else {\
         if( dt->sub_type == JD_SD_single ) {\
           ACC_TYPE = dt->type ;\
           switch(ACC_TYPE) {\
             case JD_D_sbit:\
               ACC_SIZE = dt->data.sbit.size ;\
               ACC_A[0] = dt->data.sbit.a ;\
               ACC_B[0] = dt->data.sbit.b ;\
 \
               break ;\
             case JD_D_vbit:\
             case JD_D_bit:\
               {\
                 int i, n ;\
                 n = LASTWORD(dt->data.bit.size) ;\
                 if( ACC_WD <= n ) {  /* extending ACC bit space */\
                   ACC_A = \
                     (unsigned int *)realloc( ACC_A, NBYTE(dt->data.bit.size) ) ;\
                   ACC_B = \
                     (unsigned int *)realloc( ACC_B, NBYTE(dt->data.bit.size) ) ;\
                   ACC_WD = n+1 ;\
                 }\
                 for( i = 0 ; i <= n ; i++ ) {\
                   ACC_A[i] = dt->data.bit.a[i] ;\
                   ACC_B[i] = dt->data.bit.b[i] ;\
                 }\
                 ACC_SIZE = dt->data.bit.size ;\
               }\
               break ;\
             case JD_D_int:\
               ACC_INT = dt->data.int_value ;\
 \
               break ;\
             case JD_D_float:\
               ACC_FLOAT = dt->data.float_value ;\
               break ;\
             case JD_D_double:\
               ACC_FLOAT = dt->data.double_value ;\
               break ;\
             case JD_D_string:\
               ACC_STRING = (char *)strdup(dt->data.string) ;\
               break ;\
             case JD_D_null:\
               break ;\
             default:\
               ACC_TYPE = JD_D_dt ;\
               ACC_DT = dt ;\
               break ;\
           }\
         }\
         else {\
           ACC_TYPE = JD_D_dt ;\
           ACC_DT = dt ;\
         }\
       } /* else of IS_SMLINT(dt) */\
     }\
   }\
  }
#else
#  define CALL_EXEC_POP_ACC  JD_pop_acc()
#endif
#define OUT_EXEC_POP_ACC \
    OUT0( "JD_pop_acc() ;\n" ) ; 
#  define CALL_EXEC_COPY_ALU  JD_exec_copy_alu()
#define OUT_EXEC_COPY_ALU \
    OUT0( "JD_exec_copy_alu() ;\n" ) ; 
#  define CALL_EXEC_POP_ALU  JD_exec_pop_alu()
#define OUT_EXEC_POP_ALU \
    OUT0( "JD_exec_pop_alu() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_POP_N  { \
   {\
     JD_data *dt ;\
     while( VSP && TMP_INT ) {\
       if( VS_TOP ) VS_TOP-- ;\
       else VS_TOP = VSP_LIMIT-1 ;\
       VSP-- ;\
       TMP_INT-- ;\
     }\
     \
     while( TMP_INT ) {\
 \
       SP-- ;\
 \
       TMP_INT-- ;\
     }\
   }\
  }
#else
#  define CALL_EXEC_POP_N  JD_exec_pop_n()
#endif
#define OUT_EXEC_POP_N \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_pop_n */ \n" ) ; \
    OUT0( "  {\n" ) ;\
    OUT0( "    JD_data *dt ;\n" ) ;\
    OUT0( "    while( VSP && TMP_INT ) {\n" ) ;\
    OUT0( "      if( VS_TOP ) VS_TOP-- ;\n" ) ;\
    OUT0( "      else VS_TOP = VSP_LIMIT-1 ;\n" ) ;\
    OUT0( "      VSP-- ;\n" ) ;\
    OUT0( "      TMP_INT-- ;\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "    \n" ) ;\
    OUT0( "    while( TMP_INT ) {\n" ) ;\
    OUT0( "\n" ) ;\
    OUT0( "      SP-- ;\n" ) ;\
    OUT0( "\n" ) ;\
    OUT0( "      TMP_INT-- ;\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_pop_n() ;\n" ) ; \
  }
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_LVAR_SINGLE_INT  { \
   {\
     CALL_ALLOC_DT_SINGLE_INT ;\
     PUSH_TO_STACK(TMP_DT) ;\
   }\
  }
#else
#  define CALL_EXEC_LVAR_SINGLE_INT  JD_exec_lvar_single_int()
#endif
#define OUT_EXEC_LVAR_SINGLE_INT \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_lvar_single_int */ \n" ) ; \
    OUT0( "  {\n" ) ;\
    OUT0( "    CALL_ALLOC_DT_SINGLE_INT ;\n" ) ;\
    OUT0( "    PUSH_TO_STACK(TMP_DT) ;\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_lvar_single_int() ;\n" ) ; \
  }
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_LVAR_SINGLE_BIT  { \
   {\
     CALL_ALLOC_DT_SINGLE_BIT ;\
     PUSH_TO_STACK(TMP_DT) ;\
   }\
  }
#else
#  define CALL_EXEC_LVAR_SINGLE_BIT  JD_exec_lvar_single_bit()
#endif
#define OUT_EXEC_LVAR_SINGLE_BIT \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_lvar_single_bit */ \n" ) ; \
    OUT0( "  {\n" ) ;\
    OUT0( "    CALL_ALLOC_DT_SINGLE_BIT ;\n" ) ;\
    OUT0( "    PUSH_TO_STACK(TMP_DT) ;\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_lvar_single_bit() ;\n" ) ; \
  }
#  define CALL_EXEC_LVAR_SINGLE_FLOAT  JD_exec_lvar_single_float()
#define OUT_EXEC_LVAR_SINGLE_FLOAT \
    OUT0( "JD_exec_lvar_single_float() ;\n" ) ; 
#  define CALL_EXEC_LVAR_SINGLE_DOUBLE  JD_exec_lvar_single_double()
#define OUT_EXEC_LVAR_SINGLE_DOUBLE \
    OUT0( "JD_exec_lvar_single_double() ;\n" ) ; 
#  define CALL_EXEC_LVAR_SINGLE_STRING  JD_exec_lvar_single_string()
#define OUT_EXEC_LVAR_SINGLE_STRING \
    OUT0( "JD_exec_lvar_single_string() ;\n" ) ; 
#  define CALL_EXEC_LVAR_SINGLE_SIGNAL  JD_exec_lvar_single_signal()
#define OUT_EXEC_LVAR_SINGLE_SIGNAL \
    OUT0( "JD_exec_lvar_single_signal() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_LVAR_SINGLE_OBJ  { \
   {  \
     CALL_ALLOC_DT_SINGLE_OBJ ;\
     PUSH_TO_STACK(TMP_DT) ;\
   }\
  }
#else
#  define CALL_EXEC_LVAR_SINGLE_OBJ  JD_exec_lvar_single_obj()
#endif
#define OUT_EXEC_LVAR_SINGLE_OBJ \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_lvar_single_obj */ \n" ) ; \
    OUT0( "  {  \n" ) ;\
    OUT0( "    CALL_ALLOC_DT_SINGLE_OBJ ;\n" ) ;\
    OUT0( "    PUSH_TO_STACK(TMP_DT) ;\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_lvar_single_obj() ;\n" ) ; \
  }
#  define CALL_EXEC_LVAR_SINGLE_THREAD  JD_exec_lvar_single_thread()
#define OUT_EXEC_LVAR_SINGLE_THREAD \
    OUT0( "JD_exec_lvar_single_thread() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ARRAY_INT  JD_exec_lvar_array_int()
#define OUT_EXEC_LVAR_ARRAY_INT \
    OUT0( "JD_exec_lvar_array_int() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ARRAY_BIT  JD_exec_lvar_array_bit()
#define OUT_EXEC_LVAR_ARRAY_BIT \
    OUT0( "JD_exec_lvar_array_bit() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ARRAY_FLOAT  JD_exec_lvar_array_float()
#define OUT_EXEC_LVAR_ARRAY_FLOAT \
    OUT0( "JD_exec_lvar_array_float() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ARRAY_DOUBLE  JD_exec_lvar_array_double()
#define OUT_EXEC_LVAR_ARRAY_DOUBLE \
    OUT0( "JD_exec_lvar_array_double() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ARRAY_STRING  JD_exec_lvar_array_string()
#define OUT_EXEC_LVAR_ARRAY_STRING \
    OUT0( "JD_exec_lvar_array_string() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ARRAY_SIGNAL  JD_exec_lvar_array_signal()
#define OUT_EXEC_LVAR_ARRAY_SIGNAL \
    OUT0( "JD_exec_lvar_array_signal() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ARRAY_OBJ  JD_exec_lvar_array_obj()
#define OUT_EXEC_LVAR_ARRAY_OBJ \
    OUT0( "JD_exec_lvar_array_obj() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ARRAY_THREAD  JD_exec_lvar_array_thread()
#define OUT_EXEC_LVAR_ARRAY_THREAD \
    OUT0( "JD_exec_lvar_array_thread() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ASSOC_INT  JD_exec_lvar_assoc_int()
#define OUT_EXEC_LVAR_ASSOC_INT \
    OUT0( "JD_exec_lvar_assoc_int() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ASSOC_BIT  JD_exec_lvar_assoc_bit()
#define OUT_EXEC_LVAR_ASSOC_BIT \
    OUT0( "JD_exec_lvar_assoc_bit() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ASSOC_FLOAT  JD_exec_lvar_assoc_float()
#define OUT_EXEC_LVAR_ASSOC_FLOAT \
    OUT0( "JD_exec_lvar_assoc_float() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ASSOC_DOUBLE  JD_exec_lvar_assoc_double()
#define OUT_EXEC_LVAR_ASSOC_DOUBLE \
    OUT0( "JD_exec_lvar_assoc_double() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ASSOC_STRING  JD_exec_lvar_assoc_string()
#define OUT_EXEC_LVAR_ASSOC_STRING \
    OUT0( "JD_exec_lvar_assoc_string() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ASSOC_SIGNAL  JD_exec_lvar_assoc_signal()
#define OUT_EXEC_LVAR_ASSOC_SIGNAL \
    OUT0( "JD_exec_lvar_assoc_signal() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ASSOC_OBJ  JD_exec_lvar_assoc_obj()
#define OUT_EXEC_LVAR_ASSOC_OBJ \
    OUT0( "JD_exec_lvar_assoc_obj() ;\n" ) ; 
#  define CALL_EXEC_LVAR_ASSOC_THREAD  JD_exec_lvar_assoc_thread()
#define OUT_EXEC_LVAR_ASSOC_THREAD \
    OUT0( "JD_exec_lvar_assoc_thread() ;\n" ) ; 
#  define CALL_EXEC_LVAR_STRIDED_INT  JD_exec_lvar_strided_int()
#define OUT_EXEC_LVAR_STRIDED_INT \
    OUT0( "JD_exec_lvar_strided_int() ;\n" ) ; 
#  define CALL_EXEC_LVAR_STRIDED_BIT  JD_exec_lvar_strided_bit()
#define OUT_EXEC_LVAR_STRIDED_BIT \
    OUT0( "JD_exec_lvar_strided_bit() ;\n" ) ; 
#  define CALL_EXEC_LVAR_STRIDED_FLOAT  JD_exec_lvar_strided_float()
#define OUT_EXEC_LVAR_STRIDED_FLOAT \
    OUT0( "JD_exec_lvar_strided_float() ;\n" ) ; 
#  define CALL_EXEC_LVAR_STRIDED_DOUBLE  JD_exec_lvar_strided_double()
#define OUT_EXEC_LVAR_STRIDED_DOUBLE \
    OUT0( "JD_exec_lvar_strided_double() ;\n" ) ; 
#  define CALL_EXEC_LVAR_STRIDED_STRING  JD_exec_lvar_strided_string()
#define OUT_EXEC_LVAR_STRIDED_STRING \
    OUT0( "JD_exec_lvar_strided_string() ;\n" ) ; 
#  define CALL_EXEC_LVAR_STRIDED_SIGNAL  JD_exec_lvar_strided_signal()
#define OUT_EXEC_LVAR_STRIDED_SIGNAL \
    OUT0( "JD_exec_lvar_strided_signal() ;\n" ) ; 
#  define CALL_EXEC_LVAR_STRIDED_OBJ  JD_exec_lvar_strided_obj()
#define OUT_EXEC_LVAR_STRIDED_OBJ \
    OUT0( "JD_exec_lvar_strided_obj() ;\n" ) ; 
#  define CALL_EXEC_LVAR_STRIDED_THREAD  JD_exec_lvar_strided_thread()
#define OUT_EXEC_LVAR_STRIDED_THREAD \
    OUT0( "JD_exec_lvar_strided_thread() ;\n" ) ; 
#  define CALL_EXEC_LVAR_LIST_INT  JD_exec_lvar_list_int()
#define OUT_EXEC_LVAR_LIST_INT \
    OUT0( "JD_exec_lvar_list_int() ;\n" ) ; 
#  define CALL_EXEC_LVAR_LIST_BIT  JD_exec_lvar_list_bit()
#define OUT_EXEC_LVAR_LIST_BIT \
    OUT0( "JD_exec_lvar_list_bit() ;\n" ) ; 
#  define CALL_EXEC_LVAR_LIST_FLOAT  JD_exec_lvar_list_float()
#define OUT_EXEC_LVAR_LIST_FLOAT \
    OUT0( "JD_exec_lvar_list_float() ;\n" ) ; 
#  define CALL_EXEC_LVAR_LIST_DOUBLE  JD_exec_lvar_list_double()
#define OUT_EXEC_LVAR_LIST_DOUBLE \
    OUT0( "JD_exec_lvar_list_double() ;\n" ) ; 
#  define CALL_EXEC_LVAR_LIST_STRING  JD_exec_lvar_list_string()
#define OUT_EXEC_LVAR_LIST_STRING \
    OUT0( "JD_exec_lvar_list_string() ;\n" ) ; 
#  define CALL_EXEC_LVAR_LIST_SIGNAL  JD_exec_lvar_list_signal()
#define OUT_EXEC_LVAR_LIST_SIGNAL \
    OUT0( "JD_exec_lvar_list_signal() ;\n" ) ; 
#  define CALL_EXEC_LVAR_LIST_OBJ  JD_exec_lvar_list_obj()
#define OUT_EXEC_LVAR_LIST_OBJ \
    OUT0( "JD_exec_lvar_list_obj() ;\n" ) ; 
#  define CALL_EXEC_LVAR_LIST_THREAD  JD_exec_lvar_list_thread()
#define OUT_EXEC_LVAR_LIST_THREAD \
    OUT0( "JD_exec_lvar_list_thread() ;\n" ) ; 
#  define CALL_EXEC_LVAR_STATIC  JD_exec_lvar_static()
#define OUT_EXEC_LVAR_STATIC \
    OUT0( "JD_exec_lvar_static() ;\n" ) ; 
#  define CALL_EXEC_DUPLICATE_BIT  JD_exec_duplicate_bit()
#define OUT_EXEC_DUPLICATE_BIT \
    OUT0( "JD_exec_duplicate_bit() ;\n" ) ; 
#  define CALL_EXEC_DUPLICATE_STRING  JD_exec_duplicate_string()
#define OUT_EXEC_DUPLICATE_STRING \
    OUT0( "JD_exec_duplicate_string() ;\n" ) ; 
#  define CALL_EXEC_LOAD_THREAD  JD_exec_load_thread()
#define OUT_EXEC_LOAD_THREAD \
    OUT0( "JD_exec_load_thread() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_LOADL_SINGLE  { \
   {  /* TMP_INT holds local variable index */\
     JD_data *dt ;\
     dt = STACK[THREAD->stk_frame + TMP_INT + 1 ] ;\
     CALL_EXEC_COPY_ACC(dt) ;\
   }\
  }
#else
#  define CALL_EXEC_LOADL_SINGLE  JD_exec_loadl_single()
#endif
#define OUT_EXEC_LOADL_SINGLE \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_loadl_single */ \n" ) ; \
    OUT0( "  {  /* TMP_INT holds local variable index */\n" ) ;\
    OUT0( "    JD_data *dt ;\n" ) ;\
    OUT0( "    dt = STACK[THREAD->stk_frame + TMP_INT + 1 ] ;\n" ) ;\
    OUT0( "    CALL_EXEC_COPY_ACC(dt) ;\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_loadl_single() ;\n" ) ; \
  }
#  define CALL_EXEC_LOADL_SINGLE_VAR  JD_exec_loadl_single_var()
#define OUT_EXEC_LOADL_SINGLE_VAR \
    OUT0( "JD_exec_loadl_single_var() ;\n" ) ; 
#  define CALL_EXEC_LOADL_SINGLE_STATIC  JD_exec_loadl_single_static()
#define OUT_EXEC_LOADL_SINGLE_STATIC \
    OUT0( "JD_exec_loadl_single_static() ;\n" ) ; 
#  define CALL_EXEC_GET_ASSOC_UNIT  get_assoc_unit()
#define OUT_EXEC_GET_ASSOC_UNIT \
    OUT0( "get_assoc_unit() ;\n" ) ; 
#  define CALL_EXEC_LOADL_ARRAY  JD_exec_loadl_array()
#define OUT_EXEC_LOADL_ARRAY \
    OUT0( "JD_exec_loadl_array() ;\n" ) ; 
#  define CALL_CHECK_RANGE  ()
#define OUT_CHECK_RANGE \
    OUT0( "() ;\n" ) ; 
#  define CALL_EXEC_LOADL_MARRAY  JD_exec_loadl_marray()
#define OUT_EXEC_LOADL_MARRAY \
    OUT0( "JD_exec_loadl_marray() ;\n" ) ; 
#  define CALL_EXEC_LOADL_ASSOC  JD_exec_loadl_assoc()
#define OUT_EXEC_LOADL_ASSOC \
    OUT0( "JD_exec_loadl_assoc() ;\n" ) ; 
#  define CALL_EXEC_LOADL_STRIDX  JD_exec_loadl_stridx()
#define OUT_EXEC_LOADL_STRIDX \
    OUT0( "JD_exec_loadl_stridx() ;\n" ) ; 
#  define CALL_EXEC_LOADL_LIST  JD_exec_loadl_list()
#define OUT_EXEC_LOADL_LIST \
    OUT0( "JD_exec_loadl_list() ;\n" ) ; 
#  define CALL_EXEC_LOADG_SINGLE  JD_exec_loadg_single()
#define OUT_EXEC_LOADG_SINGLE \
  if( inline_optimization > 1 ) {  \
    OUT0( "    /* Macro for JD_exec_loadg_single */ \n" ) ; \
    OUT0( "  {  /* TMP_INT holds local variable index */\n" ) ;\
    OUT0( "    JD_data *dt ;\n" ) ;\
    OUT0( "    dt = GLOBAL_DATA[TMP_INT] ;\n" ) ;\
    OUT0( "    CALL_EXEC_COPY_ACC(dt) ;\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_loadg_single() ;\n" ) ; \
  }
#  define CALL_EXEC_LOADG_SINGLE_VAR  JD_exec_loadg_single_var()
#define OUT_EXEC_LOADG_SINGLE_VAR \
    OUT0( "JD_exec_loadg_single_var() ;\n" ) ; 
#  define CALL_EXEC_LOADG_ARRAY  JD_exec_loadg_array()
#define OUT_EXEC_LOADG_ARRAY \
    OUT0( "JD_exec_loadg_array() ;\n" ) ; 
#  define CALL_EXEC_LOADG_MARRAY  JD_exec_loadg_marray()
#define OUT_EXEC_LOADG_MARRAY \
    OUT0( "JD_exec_loadg_marray() ;\n" ) ; 
#  define CALL_EXEC_LOADG_ASSOC  JD_exec_loadg_assoc()
#define OUT_EXEC_LOADG_ASSOC \
    OUT0( "JD_exec_loadg_assoc() ;\n" ) ; 
#  define CALL_EXEC_LOADG_STRIDX  JD_exec_loadg_stridx()
#define OUT_EXEC_LOADG_STRIDX \
    OUT0( "JD_exec_loadg_stridx() ;\n" ) ; 
#  define CALL_EXEC_LOADG_LIST  JD_exec_loadg_list()
#define OUT_EXEC_LOADG_LIST \
    OUT0( "JD_exec_loadg_list() ;\n" ) ; 
#  define CALL_EXEC_TO_INT  JD_exec_to_int()
#define OUT_EXEC_TO_INT \
    OUT0( "JD_exec_to_int() ;\n" ) ; 
#  define CALL_EXEC_INT_TO_BIT_SIZE  JD_exec_int_to_bit_size()
#define OUT_EXEC_INT_TO_BIT_SIZE \
    OUT0( "JD_exec_int_to_bit_size() ;\n" ) ; 
#  define CALL_EXEC_BIT_TO_BIT_SIZE  JD_exec_bit_to_bit_size()
#define OUT_EXEC_BIT_TO_BIT_SIZE \
    OUT0( "JD_exec_bit_to_bit_size() ;\n" ) ; 
#  define CALL_EXEC_FLOAT_TO_BIT_SIZE  JD_exec_float_to_bit_size()
#define OUT_EXEC_FLOAT_TO_BIT_SIZE \
    OUT0( "JD_exec_float_to_bit_size() ;\n" ) ; 
#  define CALL_EXEC_STRING_TO_BIT_SIZE  JD_exec_string_to_bit_size()
#define OUT_EXEC_STRING_TO_BIT_SIZE \
    OUT0( "JD_exec_string_to_bit_size() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_INT_TO_BIT  { \
   {\
     ACC_A[0] = ACC_INT ;\
     ACC_B[0] = 0 ;\
     ACC_SIZE = 32 ;\
     ACC_TYPE = JD_D_sbit ;\
   }\
  }
#else
#  define CALL_EXEC_INT_TO_BIT  JD_exec_int_to_bit()
#endif
#define OUT_EXEC_INT_TO_BIT \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_int_to_bit */ \n" ) ; \
    OUT0( "  {\n" ) ;\
    OUT0( "    ACC_A[0] = ACC_INT ;\n" ) ;\
    OUT0( "    ACC_B[0] = 0 ;\n" ) ;\
    OUT0( "    ACC_SIZE = 32 ;\n" ) ;\
    OUT0( "    ACC_TYPE = JD_D_sbit ;\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_int_to_bit() ;\n" ) ; \
  }
#  define CALL_EXEC_BIT_TO_INT  JD_exec_bit_to_int()
#define OUT_EXEC_BIT_TO_INT \
    OUT0( "JD_exec_bit_to_int() ;\n" ) ; 
#  define CALL_EXEC_INT_TO_FLOAT  JD_exec_int_to_float()
#define OUT_EXEC_INT_TO_FLOAT \
    OUT0( "JD_exec_int_to_float() ;\n" ) ; 
#  define CALL_EXEC_FLOAT_TO_INT  JD_exec_float_to_int()
#define OUT_EXEC_FLOAT_TO_INT \
    OUT0( "JD_exec_float_to_int() ;\n" ) ; 
#  define CALL_EXEC_BIT_TO_FLOAT  JD_exec_bit_to_float()
#define OUT_EXEC_BIT_TO_FLOAT \
    OUT0( "JD_exec_bit_to_float() ;\n" ) ; 
#  define CALL_EXEC_FLOAT_TO_BIT  JD_exec_float_to_bit()
#define OUT_EXEC_FLOAT_TO_BIT \
    OUT0( "JD_exec_float_to_bit() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_STOREL_SINGLE_INT  { \
   {  /* TMP_INT holds local variable index */\
     JD_data *dt ;\
     dt = STACK[THREAD->stk_frame + TMP_INT + 1 ] ;\
     dt->data.int_value = ACC_INT ;\
     STORE_SIZE = 32 ;\
   }\
  }
#else
#  define CALL_EXEC_STOREL_SINGLE_INT  JD_exec_storel_single_int()
#endif
#define OUT_EXEC_STOREL_SINGLE_INT \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_storel_single_int */ \n" ) ; \
    OUT0( "  {  /* TMP_INT holds local variable index */\n" ) ;\
    OUT0( "    JD_data *dt ;\n" ) ;\
    OUT0( "    dt = STACK[THREAD->stk_frame + TMP_INT + 1 ] ;\n" ) ;\
    OUT0( "    dt->data.int_value = ACC_INT ;\n" ) ;\
    OUT0( "    STORE_SIZE = 32 ;\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_storel_single_int() ;\n" ) ; \
  }
#  define CALL_EXEC_STOREL_SINGLE_FLT_DBL  JD_exec_storel_single_flt_dbl()
#define OUT_EXEC_STOREL_SINGLE_FLT_DBL \
    OUT0( "JD_exec_storel_single_flt_dbl() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_STOREL_SINGLE_BIT  { \
   {  /* TMP_INT holds local variable index */\
     JD_data *dt ;\
     unsigned int msk ;\
     dt = STACK[THREAD->stk_frame + TMP_INT + 1 ] ;\
     if( dt->type == JD_D_sbit ) {\
       STORE_SIZE = dt->data.sbit.size ;\
       msk = BITMASK(dt->data.sbit.size) ;\
       dt->data.sbit.a = ACC_A[0] & msk ;\
       dt->data.sbit.b = ACC_B[0] & msk ;\
     }\
     else {\
       int i, n ;\
       STORE_SIZE = dt->data.bit.size ;\
       if (dt->data.bit.size > ACC_SIZE) {\
         n = LASTWORD(ACC_SIZE) ;\
         for( i = 0 ; i <=n ; i++ ) {\
           dt->data.bit.a[i] = ACC_A[i] ;\
           dt->data.bit.b[i] = ACC_B[i] ;\
         }\
         n = LASTWORD(dt->data.bit.size) ;\
         for( ; i <= n ; i++ ) {\
           dt->data.bit.a[i] = 0 ;\
           dt->data.bit.b[i] = 0 ;\
         }\
       }\
       else {\
         n = LASTWORD(dt->data.bit.size) ;\
         msk = BITMASK(dt->data.bit.size) ;\
         for( i = 0 ; i < n ; i++ ) {\
           dt->data.bit.a[i] = ACC_A[i] ;\
           dt->data.bit.b[i] = ACC_B[i] ;\
         }\
         dt->data.bit.a[n] = ACC_A[n] & msk ;\
         dt->data.bit.b[n] = ACC_B[n] & msk ;\
       }\
     }\
   }\
  }
#else
#  define CALL_EXEC_STOREL_SINGLE_BIT  JD_exec_storel_single_bit()
#endif
#define OUT_EXEC_STOREL_SINGLE_BIT \
    OUT0( "JD_exec_storel_single_bit() ;\n" ) ; 
#  define CALL_EXEC_STOREL_STRING_TO_SINGLE_BIT  JD_exec_storel_string_to_single_bit()
#define OUT_EXEC_STOREL_STRING_TO_SINGLE_BIT \
    OUT0( "JD_exec_storel_string_to_single_bit() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_STRING  JD_exec_storel_single_string()
#define OUT_EXEC_STOREL_SINGLE_STRING \
    OUT0( "JD_exec_storel_single_string() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_STRING_NULL  JD_exec_storel_single_string_null()
#define OUT_EXEC_STOREL_SINGLE_STRING_NULL \
    OUT0( "JD_exec_storel_single_string_null() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_STOREL_SINGLE_OBJ  { \
   {  /* TMP_INT holds local variable index */\
     JD_data *dt ;\
     dt = STACK[THREAD->stk_frame + TMP_INT + 1 ] ;\
     if( dt->data.obj.ect && (--dt->data.obj.ect->ref_count) == 0 ) {\
       (dt->data.obj.ect->dealloc)( \
         (void *)dt->data.obj.ect->table,\
         dt->data.obj.ect->num_entry,\
         dt->data.obj.ect->tbl_size\
       ) ;\
       DEALLOC_OBJ_TABLE(dt->data.obj.ect) ;\
     }\
     if( ACC_TYPE == JD_D_null ) dt->data.obj.ect = NULL ;\
     else {\
 \
       dt->data.obj.ect = ACC_DT->data.obj.ect ;\
       if( dt->data.obj.ect ) dt->data.obj.ect->ref_count++ ;\
     }\
   }\
  }
#else
#  define CALL_EXEC_STOREL_SINGLE_OBJ  JD_exec_storel_single_obj()
#endif
#define OUT_EXEC_STOREL_SINGLE_OBJ \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_storel_single_obj */ \n" ) ; \
    OUT0( "  {  /* TMP_INT holds local variable index */\n" ) ;\
    OUT0( "    JD_data *dt ;\n" ) ;\
    OUT0( "    dt = STACK[THREAD->stk_frame + TMP_INT + 1 ] ;\n" ) ;\
    OUT0( "    if( dt->data.obj.ect && (--dt->data.obj.ect->ref_count) == 0 ) {\n" ) ;\
    OUT0( "      (dt->data.obj.ect->dealloc)( \n" ) ;\
    OUT0( "        (void *)dt->data.obj.ect->table,\n" ) ;\
    OUT0( "        dt->data.obj.ect->num_entry,\n" ) ;\
    OUT0( "        dt->data.obj.ect->tbl_size\n" ) ;\
    OUT0( "      ) ;\n" ) ;\
    OUT0( "      DEALLOC_OBJ_TABLE(dt->data.obj.ect) ;\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "    if( ACC_TYPE == JD_D_null ) dt->data.obj.ect = NULL ;\n" ) ;\
    OUT0( "    else {\n" ) ;\
    OUT0( "\n" ) ;\
    OUT0( "      dt->data.obj.ect = ACC_DT->data.obj.ect ;\n" ) ;\
    OUT0( "      if( dt->data.obj.ect ) dt->data.obj.ect->ref_count++ ;\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_storel_single_obj() ;\n" ) ; \
  }
#  define CALL_EXEC_STOREL_SINGLE_OBJ_NULL  JD_exec_storel_single_obj_null()
#define OUT_EXEC_STOREL_SINGLE_OBJ_NULL \
    OUT0( "JD_exec_storel_single_obj_null() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_THREAD  JD_exec_storel_single_thread()
#define OUT_EXEC_STOREL_SINGLE_THREAD \
    OUT0( "JD_exec_storel_single_thread() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_THREAD_NULL  JD_exec_storel_single_thread_null()
#define OUT_EXEC_STOREL_SINGLE_THREAD_NULL \
    OUT0( "JD_exec_storel_single_thread_null() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_SIGNAL  JD_exec_storel_single_signal()
#define OUT_EXEC_STOREL_SINGLE_SIGNAL \
    OUT0( "JD_exec_storel_single_signal() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_SIGNAL_NULL  JD_exec_storel_single_signal_null()
#define OUT_EXEC_STOREL_SINGLE_SIGNAL_NULL \
    OUT0( "JD_exec_storel_single_signal_null() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_DT  JD_exec_storel_single_dt()
#define OUT_EXEC_STOREL_SINGLE_DT \
    OUT0( "JD_exec_storel_single_dt() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_INT_STATIC  JD_exec_storel_single_int_static()
#define OUT_EXEC_STOREL_SINGLE_INT_STATIC \
    OUT0( "JD_exec_storel_single_int_static() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_FLT_DBL_STATIC  JD_exec_storel_single_flt_dbl_static()
#define OUT_EXEC_STOREL_SINGLE_FLT_DBL_STATIC \
    OUT0( "JD_exec_storel_single_flt_dbl_static() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_BIT_STATIC  JD_exec_storel_single_bit_static()
#define OUT_EXEC_STOREL_SINGLE_BIT_STATIC \
    OUT0( "JD_exec_storel_single_bit_static() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_STRING_STATIC  JD_exec_storel_single_string_static()
#define OUT_EXEC_STOREL_SINGLE_STRING_STATIC \
    OUT0( "JD_exec_storel_single_string_static() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_STRING_STATIC_NULL  JD_exec_storel_single_string_static_null()
#define OUT_EXEC_STOREL_SINGLE_STRING_STATIC_NULL \
    OUT0( "JD_exec_storel_single_string_static_null() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_OBJ_STATIC  JD_exec_storel_single_obj_static()
#define OUT_EXEC_STOREL_SINGLE_OBJ_STATIC \
    OUT0( "JD_exec_storel_single_obj_static() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_OBJ_STATIC_NULL  JD_exec_storel_single_obj_static_null()
#define OUT_EXEC_STOREL_SINGLE_OBJ_STATIC_NULL \
    OUT0( "JD_exec_storel_single_obj_static_null() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_THREAD_STATIC  JD_exec_storel_single_thread_static()
#define OUT_EXEC_STOREL_SINGLE_THREAD_STATIC \
    OUT0( "JD_exec_storel_single_thread_static() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_SIGNAL_STATIC  JD_exec_storel_single_signal_static()
#define OUT_EXEC_STOREL_SINGLE_SIGNAL_STATIC \
    OUT0( "JD_exec_storel_single_signal_static() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_SIGNAL_STATIC_NULL  JD_exec_storel_single_signal_static_null()
#define OUT_EXEC_STOREL_SINGLE_SIGNAL_STATIC_NULL \
    OUT0( "JD_exec_storel_single_signal_static_null() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SINGLE_DT_STATIC  JD_exec_storel_single_dt_static()
#define OUT_EXEC_STOREL_SINGLE_DT_STATIC \
    OUT0( "JD_exec_storel_single_dt_static() ;\n" ) ; 
#  define CALL_EXEC_STOREL_SUBBIT  JD_exec_storel_subbit()
#define OUT_EXEC_STOREL_SUBBIT \
    OUT0( "JD_exec_storel_subbit() ;\n" ) ; 
#  define CALL_EXEC_STOREL_ARRAY  JD_exec_storel_array()
#define OUT_EXEC_STOREL_ARRAY \
    OUT0( "JD_exec_storel_array() ;\n" ) ; 
#  define CALL_EXEC_STOREL_ARRAY_SUBBIT  JD_exec_storel_array_subbit()
#define OUT_EXEC_STOREL_ARRAY_SUBBIT \
    OUT0( "JD_exec_storel_array_subbit() ;\n" ) ; 
#  define CALL_EXEC_STOREL_MARRAY_SUBBIT  JD_exec_storel_marray_subbit()
#define OUT_EXEC_STOREL_MARRAY_SUBBIT \
    OUT0( "JD_exec_storel_marray_subbit() ;\n" ) ; 
#  define CALL_EXEC_STOREL_MARRAY  JD_exec_storel_marray()
#define OUT_EXEC_STOREL_MARRAY \
    OUT0( "JD_exec_storel_marray() ;\n" ) ; 
#  define CALL_EXEC_STOREL_ASSOC_SUBBIT  JD_exec_storel_assoc_subbit()
#define OUT_EXEC_STOREL_ASSOC_SUBBIT \
    OUT0( "JD_exec_storel_assoc_subbit() ;\n" ) ; 
#  define CALL_EXEC_STOREL_ASSOC  JD_exec_storel_assoc()
#define OUT_EXEC_STOREL_ASSOC \
    OUT0( "JD_exec_storel_assoc() ;\n" ) ; 
#  define CALL_EXEC_STOREL_STRIDX  JD_exec_storel_stridx()
#define OUT_EXEC_STOREL_STRIDX \
    OUT0( "JD_exec_storel_stridx() ;\n" ) ; 
#  define CALL_EXEC_STOREL_STRIDX_SUBBIT  JD_exec_storel_stridx_subbit()
#define OUT_EXEC_STOREL_STRIDX_SUBBIT \
    OUT0( "JD_exec_storel_stridx_subbit() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_INT  JD_exec_storeg_single_int()
#define OUT_EXEC_STOREG_SINGLE_INT \
    OUT0( "JD_exec_storeg_single_int() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_FLT_DBL  JD_exec_storeg_single_flt_dbl()
#define OUT_EXEC_STOREG_SINGLE_FLT_DBL \
    OUT0( "JD_exec_storeg_single_flt_dbl() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_BIT  JD_exec_storeg_single_bit()
#define OUT_EXEC_STOREG_SINGLE_BIT \
    OUT0( "JD_exec_storeg_single_bit() ;\n" ) ; 
#  define CALL_EXEC_STOREG_STRING_TO_SINGLE_BIT  JD_exec_storeg_string_to_single_bit()
#define OUT_EXEC_STOREG_STRING_TO_SINGLE_BIT \
    OUT0( "JD_exec_storeg_string_to_single_bit() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_STRING  JD_exec_storeg_single_string()
#define OUT_EXEC_STOREG_SINGLE_STRING \
    OUT0( "JD_exec_storeg_single_string() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_STRING_NULL  JD_exec_storeg_single_string_null()
#define OUT_EXEC_STOREG_SINGLE_STRING_NULL \
    OUT0( "JD_exec_storeg_single_string_null() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_OBJ  JD_exec_storeg_single_obj()
#define OUT_EXEC_STOREG_SINGLE_OBJ \
    OUT0( "JD_exec_storeg_single_obj() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_OBJ_NULL  JD_exec_storeg_single_obj_null()
#define OUT_EXEC_STOREG_SINGLE_OBJ_NULL \
    OUT0( "JD_exec_storeg_single_obj_null() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_THREAD  JD_exec_storeg_single_thread()
#define OUT_EXEC_STOREG_SINGLE_THREAD \
    OUT0( "JD_exec_storeg_single_thread() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_SIGNAL  JD_exec_storeg_single_signal()
#define OUT_EXEC_STOREG_SINGLE_SIGNAL \
    OUT0( "JD_exec_storeg_single_signal() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_SIGNAL_NULL  JD_exec_storeg_single_signal_null()
#define OUT_EXEC_STOREG_SINGLE_SIGNAL_NULL \
    OUT0( "JD_exec_storeg_single_signal_null() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SINGLE_DT  JD_exec_storeg_single_dt()
#define OUT_EXEC_STOREG_SINGLE_DT \
    OUT0( "JD_exec_storeg_single_dt() ;\n" ) ; 
#  define CALL_EXEC_STOREG_SUBBIT  JD_exec_storeg_subbit()
#define OUT_EXEC_STOREG_SUBBIT \
    OUT0( "JD_exec_storeg_subbit() ;\n" ) ; 
#  define CALL_EXEC_STOREG_ARRAY  JD_exec_storeg_array()
#define OUT_EXEC_STOREG_ARRAY \
    OUT0( "JD_exec_storeg_array() ;\n" ) ; 
#  define CALL_EXEC_STOREG_ARRAY_SUBBIT  JD_exec_storeg_array_subbit()
#define OUT_EXEC_STOREG_ARRAY_SUBBIT \
    OUT0( "JD_exec_storeg_array_subbit() ;\n" ) ; 
#  define CALL_EXEC_STOREG_MARRAY  JD_exec_storeg_marray()
#define OUT_EXEC_STOREG_MARRAY \
    OUT0( "JD_exec_storeg_marray() ;\n" ) ; 
#  define CALL_EXEC_STOREG_MARRAY_SUBBIT  JD_exec_storeg_marray_subbit()
#define OUT_EXEC_STOREG_MARRAY_SUBBIT \
    OUT0( "JD_exec_storeg_marray_subbit() ;\n" ) ; 
#  define CALL_EXEC_STOREG_ASSOC  JD_exec_storeg_assoc()
#define OUT_EXEC_STOREG_ASSOC \
    OUT0( "JD_exec_storeg_assoc() ;\n" ) ; 
#  define CALL_EXEC_STOREG_ASSOC_SUBBIT  JD_exec_storeg_assoc_subbit()
#define OUT_EXEC_STOREG_ASSOC_SUBBIT \
    OUT0( "JD_exec_storeg_assoc_subbit() ;\n" ) ; 
#  define CALL_EXEC_STOREG_STRIDX  JD_exec_storeg_stridx()
#define OUT_EXEC_STOREG_STRIDX \
    OUT0( "JD_exec_storeg_stridx() ;\n" ) ; 
#  define CALL_EXEC_STOREG_STRIDX_SUBBIT  JD_exec_storeg_stridx_subbit()
#define OUT_EXEC_STOREG_STRIDX_SUBBIT \
    OUT0( "JD_exec_storeg_stridx_subbit() ;\n" ) ; 
#  define CALL_EXEC_LIST  JD_exec_list()
#define OUT_EXEC_LIST \
    OUT0( "JD_exec_list() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_GET_SUBBIT  { \
   {  \
     unsigned int lmsk, umsk, uumsk ;\
     int ub, lb ;\
     int aub, alb ;\
     lb = ACC_INT ;  /* ACC should hold lb */\
     CALL_EXEC_POP_ACC ;\
     ub = ACC_INT ;  /* ub is pushed to stack */\
 \
     CALL_EXEC_POP_ACC ; /* target data for get_subbit */\
 \
     if( I_ENDIAN == 0 ) {\
       aub = ub ;\
       alb = lb ;\
     }\
     else if( I_ENDIAN == -1 ) {\
       aub = ub-L_BIT ;\
       alb = lb-L_BIT ;\
     }\
     else {\
       aub = L_BIT - ub ;\
       alb = L_BIT - lb ;\
     }\
     if( ACC_TYPE == JD_D_sbit ) {\
       umsk = (unsigned int)0xffffffff >> (32-aub) ;\
       ACC_A[0] = (ACC_A[0] & umsk) >> alb  ;\
       ACC_B[0] = (ACC_B[0] & umsk) >> alb  ;\
     }\
     else {\
       int i, j, an, a, b, ls, us, ns, nwn ;\
       \
       /* implement (ACC>>alb)&umsk */\
       \
       i = LASTWORD(alb+1) ;\
       an = LASTWORD(ACC_SIZE) ;\
       ls = (alb%32) ;\
       us = 32-ls ;\
       lmsk = (unsigned int)0xffffffff >> ls ;\
       uumsk = (1 << us )-1 ;\
       if( uumsk ) uumsk = ~uumsk ;\
       ns = aub - alb +1 ;\
       umsk = (ns%32)?(1 << (ns%32))-1:0xffffffff ;\
       nwn = LASTWORD(ns) ;\
       for( j = 0 ; j < nwn ; i++, j++ ) {\
         ACC_A[j] = ( ((ACC_A[i]>>ls)&lmsk) | ((ACC_A[i+1]<<us)&uumsk) ) ;\
         ACC_B[j] = ( ((ACC_B[i]>>ls)&lmsk) | ((ACC_B[i+1]<<us)&uumsk) ) ;\
       }\
       if( i == an ) {\
         a = b = 0 ;\
       }\
       else {\
         a = ACC_A[i+1] ;\
         b = ACC_B[i+1] ;\
       }\
       ACC_A[j] = ( ((ACC_A[i]>>ls)&lmsk) | ((a<<us)&uumsk) ) & umsk ;\
       ACC_B[j] = ( ((ACC_B[i]>>ls)&lmsk) | ((b<<us)&uumsk) ) & umsk ;\
       ACC_SIZE = ns ;\
     }\
   }\
  }
#else
#  define CALL_EXEC_GET_SUBBIT  JD_exec_get_subbit()
#endif
#define OUT_EXEC_GET_SUBBIT \
    OUT0( "JD_exec_get_subbit() ;\n" ) ; 
#  define CALL_EXEC_INC_BIT  JD_exec_inc_bit()
#define OUT_EXEC_INC_BIT \
    OUT0( "JD_exec_inc_bit() ;\n" ) ; 
#  define CALL_EXEC_DEC_BIT  JD_exec_dec_bit()
#define OUT_EXEC_DEC_BIT \
    OUT0( "JD_exec_dec_bit() ;\n" ) ; 
#  define CALL_EXEC_TOP_OF_STACK  JD_top_of_stack()
#define OUT_EXEC_TOP_OF_STACK \
    OUT0( "JD_top_of_stack() ;\n" ) ; 
#  define CALL_EXEC_CMP_BIT_INT  JD_exec_cmp_bit_int()
#define OUT_EXEC_CMP_BIT_INT \
    OUT0( "JD_exec_cmp_bit_int() ;\n" ) ; 
#  define CALL_EXEC_CMP_FLOAT_INT  JD_exec_cmp_float_int()
#define OUT_EXEC_CMP_FLOAT_INT \
    OUT0( "JD_exec_cmp_float_int() ;\n" ) ; 
#  define CALL_EXEC_CMP_INT_BIT  JD_exec_cmp_int_bit()
#define OUT_EXEC_CMP_INT_BIT \
    OUT0( "JD_exec_cmp_int_bit() ;\n" ) ; 
#  define CALL_EXEC_CMP_BIT_BIT  JD_exec_cmp_bit_bit()
#define OUT_EXEC_CMP_BIT_BIT \
    OUT0( "JD_exec_cmp_bit_bit() ;\n" ) ; 
#  define CALL_EXEC_CMP_BIT_FLOAT  JD_exec_cmp_bit_float()
#define OUT_EXEC_CMP_BIT_FLOAT \
    OUT0( "JD_exec_cmp_bit_float() ;\n" ) ; 
#  define CALL_EXEC_CMP_INT_FLOAT  JD_exec_cmp_int_float()
#define OUT_EXEC_CMP_INT_FLOAT \
    OUT0( "JD_exec_cmp_int_float() ;\n" ) ; 
#  define CALL_EXEC_CMP_FLOAT_BIT  JD_exec_cmp_float_bit()
#define OUT_EXEC_CMP_FLOAT_BIT \
    OUT0( "JD_exec_cmp_float_bit() ;\n" ) ; 
#  define CALL_EXEC_CMP_FLOAT_FLOAT  JD_exec_cmp_float_float()
#define OUT_EXEC_CMP_FLOAT_FLOAT \
    OUT0( "JD_exec_cmp_float_float() ;\n" ) ; 
#  define CALL_EXEC_CMP_STRING_STRING  JD_exec_cmp_string_string()
#define OUT_EXEC_CMP_STRING_STRING \
    OUT0( "JD_exec_cmp_string_string() ;\n" ) ; 
#  define CALL_EXEC_CMP_SIGNAL_SIGNAL  JD_exec_cmp_signal_signal()
#define OUT_EXEC_CMP_SIGNAL_SIGNAL \
    OUT0( "JD_exec_cmp_signal_signal() ;\n" ) ; 
#  define CALL_EXEC_CMP_OBJ_OBJ  JD_exec_cmp_obj_obj()
#define OUT_EXEC_CMP_OBJ_OBJ \
    OUT0( "JD_exec_cmp_obj_obj() ;\n" ) ; 
#  define CALL_EXEC_CMP_THREAD_THREAD  JD_exec_cmp_thread_thread()
#define OUT_EXEC_CMP_THREAD_THREAD \
    OUT0( "JD_exec_cmp_thread_thread() ;\n" ) ; 
#  define CALL_EXEC_CMPX_INT_BIT  JD_exec_cmpx_int_bit()
#define OUT_EXEC_CMPX_INT_BIT \
    OUT0( "JD_exec_cmpx_int_bit() ;\n" ) ; 
#  define CALL_EXEC_CMPX_BIT_INT  JD_exec_cmpx_bit_int()
#define OUT_EXEC_CMPX_BIT_INT \
    OUT0( "JD_exec_cmpx_bit_int() ;\n" ) ; 
#  define CALL_EXEC_CMPX_BIT_BIT  JD_exec_cmpx_bit_bit()
#define OUT_EXEC_CMPX_BIT_BIT \
    OUT0( "JD_exec_cmpx_bit_bit() ;\n" ) ; 
#  define CALL_EXEC_CMPZ_INT_BIT  JD_exec_cmpz_int_bit()
#define OUT_EXEC_CMPZ_INT_BIT \
    OUT0( "JD_exec_cmpz_int_bit() ;\n" ) ; 
#  define CALL_EXEC_CMPZ_BIT_INT  JD_exec_cmpz_bit_int()
#define OUT_EXEC_CMPZ_BIT_INT \
    OUT0( "JD_exec_cmpz_bit_int() ;\n" ) ; 
#  define CALL_EXEC_CMPZ_BIT_BIT  JD_exec_cmpz_bit_bit()
#define OUT_EXEC_CMPZ_BIT_BIT \
    OUT0( "JD_exec_cmpz_bit_bit() ;\n" ) ; 
#  define CALL_EXEC_CONCAT_INT_INT  JD_exec_concat_int_int()
#define OUT_EXEC_CONCAT_INT_INT \
    OUT0( "JD_exec_concat_int_int() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_CONCAT_BIT_INT  { \
   {  \
     int i, n, j, size, nsize ;\
     JD_data *dt ;\
     dt = POP_STACK ;\
     size = (dt->type == JD_D_sbit)?dt->data.sbit.size:dt->data.bit.size ;\
     nsize = size+32 ;\
     n = LASTWORD(nsize) ;\
     if( ACC_WD <= n ) {  /* extending ACC bit space */\
       ACC_A = \
         (unsigned int *)realloc( ACC_A, NBYTE(nsize) ) ;\
       ACC_B = \
         (unsigned int *)realloc( ACC_B, NBYTE(nsize) ) ;\
       ACC_WD = n+1 ;\
     }\
     ACC_A[0] = ACC_INT ;\
     ACC_B[0] = 0 ;\
     n = LASTWORD(size) ;\
     if( dt->type == JD_D_sbit ) {\
       ACC_A[1] = dt->data.sbit.a ;\
       ACC_B[1] = dt->data.sbit.b ;\
     }\
     else {\
       for( i = 0, j = 1 ; i <= n ; i++, j++ ) {\
         ACC_A[j] = dt->data.bit.a[i] ;\
         ACC_B[j] = dt->data.bit.b[i] ;\
       }\
     }\
     ACC_SIZE = nsize ;\
     ACC_TYPE = JD_D_bit ;\
   }\
  }
#else
#  define CALL_EXEC_CONCAT_BIT_INT  JD_exec_concat_bit_int()
#endif
#define OUT_EXEC_CONCAT_BIT_INT \
  if( inline_optimization > 1 ) {  \
    OUT0( "    /* Macro for JD_exec_concat_bit_int */ \n" ) ; \
    OUT0( "  {  \n" ) ;\
    OUT0( "    int i, n, j, size, nsize ;\n" ) ;\
    OUT0( "    JD_data *dt ;\n" ) ;\
    OUT0( "    dt = POP_STACK ;\n" ) ;\
    OUT0( "    size = (dt->type == JD_D_sbit)?dt->data.sbit.size:dt->data.bit.size ;\n" ) ;\
    OUT0( "    nsize = size+32 ;\n" ) ;\
    OUT0( "    n = LASTWORD(nsize) ;\n" ) ;\
    OUT0( "    if( ACC_WD <= n ) {  /* extending ACC bit space */\n" ) ;\
    OUT0( "      ACC_A = \n" ) ;\
    OUT0( "        (unsigned int *)realloc( ACC_A, NBYTE(nsize) ) ;\n" ) ;\
    OUT0( "      ACC_B = \n" ) ;\
    OUT0( "        (unsigned int *)realloc( ACC_B, NBYTE(nsize) ) ;\n" ) ;\
    OUT0( "      ACC_WD = n+1 ;\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "    ACC_A[0] = ACC_INT ;\n" ) ;\
    OUT0( "    ACC_B[0] = 0 ;\n" ) ;\
    OUT0( "    n = LASTWORD(size) ;\n" ) ;\
    OUT0( "    if( dt->type == JD_D_sbit ) {\n" ) ;\
    OUT0( "      ACC_A[1] = dt->data.sbit.a ;\n" ) ;\
    OUT0( "      ACC_B[1] = dt->data.sbit.b ;\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "    else {\n" ) ;\
    OUT0( "      for( i = 0, j = 1 ; i <= n ; i++, j++ ) {\n" ) ;\
    OUT0( "        ACC_A[j] = dt->data.bit.a[i] ;\n" ) ;\
    OUT0( "        ACC_B[j] = dt->data.bit.b[i] ;\n" ) ;\
    OUT0( "      }\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "    ACC_SIZE = nsize ;\n" ) ;\
    OUT0( "    ACC_TYPE = JD_D_bit ;\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_concat_bit_int() ;\n" ) ; \
  }
#  define CALL_EXEC_CONCAT_INT_BIT  JD_exec_concat_int_bit()
#define OUT_EXEC_CONCAT_INT_BIT \
    OUT0( "JD_exec_concat_int_bit() ;\n" ) ; 
#  define CALL_EXEC_CONCAT_BIT_BIT  JD_exec_concat_bit_bit()
#define OUT_EXEC_CONCAT_BIT_BIT \
    OUT0( "JD_exec_concat_bit_bit() ;\n" ) ; 
#  define CALL_EXEC_CONCAT_STRING_STRING  JD_exec_concat_string_string()
#define OUT_EXEC_CONCAT_STRING_STRING \
    OUT0( "JD_exec_concat_string_string() ;\n" ) ; 
#  define CALL_EXEC_LSHIFT_BIT  JD_exec_lshift_bit()
#define OUT_EXEC_LSHIFT_BIT \
    OUT0( "JD_exec_lshift_bit() ;\n" ) ; 
#  define CALL_EXEC_RSHIFT_BIT  JD_exec_rshift_bit()
#define OUT_EXEC_RSHIFT_BIT \
    OUT0( "JD_exec_rshift_bit() ;\n" ) ; 
#  define CALL_EXEC_LSHIFT_INT  JD_exec_lshift_int()
#define OUT_EXEC_LSHIFT_INT \
    OUT0( "JD_exec_lshift_int() ;\n" ) ; 
#  define CALL_EXEC_RSHIFT_INT  JD_exec_rshift_int()
#define OUT_EXEC_RSHIFT_INT \
    OUT0( "JD_exec_rshift_int() ;\n" ) ; 
#  define CALL_EXEC_URSHIFT_INT  JD_exec_urshift_int()
#define OUT_EXEC_URSHIFT_INT \
    OUT0( "JD_exec_urshift_int() ;\n" ) ; 
#  define CALL_EXEC_STRING_EQEQ_STRING  JD_exec_string_eqeq_string()
#define OUT_EXEC_STRING_EQEQ_STRING \
    OUT0( "JD_exec_string_eqeq_string() ;\n" ) ; 
#  define CALL_EXEC_SIGNAL_EQEQ_SIGNAL  JD_exec_signal_eqeq_signal()
#define OUT_EXEC_SIGNAL_EQEQ_SIGNAL \
    OUT0( "JD_exec_signal_eqeq_signal() ;\n" ) ; 
#  define CALL_EXEC_STRING_NE_STRING  JD_exec_string_ne_string()
#define OUT_EXEC_STRING_NE_STRING \
    OUT0( "JD_exec_string_ne_string() ;\n" ) ; 
#  define CALL_EXEC_SIGNAL_NE_SIGNAL  JD_exec_signal_ne_signal()
#define OUT_EXEC_SIGNAL_NE_SIGNAL \
    OUT0( "JD_exec_signal_ne_signal() ;\n" ) ; 
#  define CALL_EXEC_OBJ_EQEQ_OBJ  JD_exec_obj_eqeq_obj()
#define OUT_EXEC_OBJ_EQEQ_OBJ \
    OUT0( "JD_exec_obj_eqeq_obj() ;\n" ) ; 
#  define CALL_EXEC_OBJ_NE_OBJ  JD_exec_obj_ne_obj()
#define OUT_EXEC_OBJ_NE_OBJ \
    OUT0( "JD_exec_obj_ne_obj() ;\n" ) ; 
#  define CALL_EXEC_OBJ_EQEQEQ_OBJ  JD_exec_obj_eqeqeq_obj()
#define OUT_EXEC_OBJ_EQEQEQ_OBJ \
    OUT0( "JD_exec_obj_eqeqeq_obj() ;\n" ) ; 
#  define CALL_EXEC_OBJ_NEQEQ_OBJ  JD_exec_obj_neqeq_obj()
#define OUT_EXEC_OBJ_NEQEQ_OBJ \
    OUT0( "JD_exec_obj_neqeq_obj() ;\n" ) ; 
#  define CALL_EXEC_THREAD_EQEQ_THREAD  JD_exec_thread_eqeq_thread()
#define OUT_EXEC_THREAD_EQEQ_THREAD \
    OUT0( "JD_exec_thread_eqeq_thread() ;\n" ) ; 
#  define CALL_EXEC_THREAD_EQEQEQ_THREAD  JD_exec_thread_eqeqeq_thread()
#define OUT_EXEC_THREAD_EQEQEQ_THREAD \
    OUT0( "JD_exec_thread_eqeqeq_thread() ;\n" ) ; 
#  define CALL_EXEC_THREAD_NE_THREAD  JD_exec_thread_ne_thread()
#define OUT_EXEC_THREAD_NE_THREAD \
    OUT0( "JD_exec_thread_ne_thread() ;\n" ) ; 
#  define CALL_EXEC_THREAD_NEQEQ_THREAD  JD_exec_thread_neqeq_thread()
#define OUT_EXEC_THREAD_NEQEQ_THREAD \
    OUT0( "JD_exec_thread_neqeq_thread() ;\n" ) ; 
#  define CALL_EXEC_POP_EQEQ_NULL  JD_exec_pop_eqeq_null()
#define OUT_EXEC_POP_EQEQ_NULL \
    OUT0( "JD_exec_pop_eqeq_null() ;\n" ) ; 
#  define CALL_EXEC_POP_NE_NULL  JD_exec_pop_ne_null()
#define OUT_EXEC_POP_NE_NULL \
    OUT0( "JD_exec_pop_ne_null() ;\n" ) ; 
#  define CALL_EXEC_NULL_EQEQ_ACC  JD_exec_null_eqeq_acc()
#define OUT_EXEC_NULL_EQEQ_ACC \
    OUT0( "JD_exec_null_eqeq_acc() ;\n" ) ; 
#  define CALL_EXEC_NULL_NE_ACC  JD_exec_null_ne_acc()
#define OUT_EXEC_NULL_NE_ACC \
    OUT0( "JD_exec_null_ne_acc() ;\n" ) ; 
#  define CALL_EXEC_GEN_FRAME  JD_exec_gen_frame()
#define OUT_EXEC_GEN_FRAME \
    OUT0( "JD_exec_gen_frame() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_GEN_M_FRAME  { \
   { \
     JD_data *dt ;\
     dt = JD_alloc_int() ;\
     PUSH_TO_STACK(dt) ;\
     dt->data.int_value = THREAD->stk_frame ;\
     THREAD->stk_frame = SP-1 ;\
     if( THREAD->this ) {\
       PUSH_TO_STACK(THREAD->this) ;  /* same previous object */\
     }\
     else {\
       PUSH_TO_STACK( JD_alloc_int() ) ; /* dummy object */\
     }\
     THREAD->this = ACC_DT ; /* ACC_DT should hold new 'this' */\
   }\
  }
#else
#  define CALL_EXEC_GEN_M_FRAME  JD_exec_gen_m_frame()
#endif
#define OUT_EXEC_GEN_M_FRAME \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_gen_m_frame */ \n" ) ; \
    OUT0( "  { \n" ) ;\
    OUT0( "    JD_data *dt ;\n" ) ;\
    OUT0( "    dt = JD_alloc_int() ;\n" ) ;\
    OUT0( "    PUSH_TO_STACK(dt) ;\n" ) ;\
    OUT0( "    dt->data.int_value = THREAD->stk_frame ;\n" ) ;\
    OUT0( "    THREAD->stk_frame = SP-1 ;\n" ) ;\
    OUT0( "    if( THREAD->this ) {\n" ) ;\
    OUT0( "      PUSH_TO_STACK(THREAD->this) ;  /* same previous object */\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "    else {\n" ) ;\
    OUT0( "      PUSH_TO_STACK( JD_alloc_int() ) ; /* dummy object */\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "    THREAD->this = ACC_DT ; /* ACC_DT should hold new 'this' */\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_gen_m_frame() ;\n" ) ; \
  }
#  define CALL_EXEC_GEN_A_FRAME  JD_exec_gen_a_frame()
#define OUT_EXEC_GEN_A_FRAME \
    OUT0( "JD_exec_gen_a_frame() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_POP_THIS  { \
   { \
     JD_data *dt ;\
     \
     dt = STACK[THREAD->stk_frame+1] ;\
     if( dt->type == JD_D_object )\
       THREAD->this = dt ;  /* pop previous object */\
     else THREAD->this = NULL ;\
   }\
  }
#else
#  define CALL_EXEC_POP_THIS  JD_exec_pop_this()
#endif
#define OUT_EXEC_POP_THIS \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_pop_this */ \n" ) ; \
    OUT0( "  { \n" ) ;\
    OUT0( "    JD_data *dt ;\n" ) ;\
    OUT0( "    \n" ) ;\
    OUT0( "    dt = STACK[THREAD->stk_frame+1] ;\n" ) ;\
    OUT0( "    if( dt->type == JD_D_object )\n" ) ;\
    OUT0( "      THREAD->this = dt ;  /* pop previous object */\n" ) ;\
    OUT0( "    else THREAD->this = NULL ;\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_pop_this() ;\n" ) ; \
  }
#  define CALL_EXEC_POP_THIS_NEW  JD_exec_pop_this_new()
#define OUT_EXEC_POP_THIS_NEW \
    OUT0( "JD_exec_pop_this_new() ;\n" ) ; 
#  define CALL_EXEC_VAR_ARG  JD_exec_var_arg()
#define OUT_EXEC_VAR_ARG \
    OUT0( "JD_exec_var_arg() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_COPY_ARG_SINGLE_INT  { \
   { \
     JD_data *dt ;\
     \
     dt = STACK[THREAD->stk_frame-TMP_INT] ;\
     if( IS_SMLINT(dt) ) TMP_DT->data.int_value = SMLINT2INT(dt) ;\
     else switch(dt->type) {\
       case JD_D_int:\
         TMP_DT->data.int_value = dt->data.int_value ;\
         break ;\
       case JD_D_bit:\
         TMP_DT->data.int_value = dt->data.bit.a[0] ;\
         /* may check if b is zero or not */\
         break ;\
       case JD_D_sbit:\
         TMP_DT->data.int_value = dt->data.sbit.a ;\
         /* may check if b is zero or not */\
         break ;\
       case JD_D_float:\
         TMP_DT->data.int_value = dt->data.float_value ;\
         break ;\
       case JD_D_double:\
         TMP_DT->data.int_value = dt->data.double_value ;\
         break ;\
     }\
   }\
  }
#else
#  define CALL_EXEC_COPY_ARG_SINGLE_INT  JD_exec_copy_arg_single_int()
#endif
#define OUT_EXEC_COPY_ARG_SINGLE_INT \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_copy_arg_single_int */ \n" ) ; \
    OUT0( "  { \n" ) ;\
    OUT0( "    JD_data *dt ;\n" ) ;\
    OUT0( "    \n" ) ;\
    OUT0( "    dt = STACK[THREAD->stk_frame-TMP_INT] ;\n" ) ;\
    OUT0( "    if( IS_SMLINT(dt) ) TMP_DT->data.int_value = SMLINT2INT(dt) ;\n" ) ;\
    OUT0( "    else switch(dt->type) {\n" ) ;\
    OUT0( "      case JD_D_int:\n" ) ;\
    OUT0( "        TMP_DT->data.int_value = dt->data.int_value ;\n" ) ;\
    OUT0( "        break ;\n" ) ;\
    OUT0( "      case JD_D_bit:\n" ) ;\
    OUT0( "        TMP_DT->data.int_value = dt->data.bit.a[0] ;\n" ) ;\
    OUT0( "        /* may check if b is zero or not */\n" ) ;\
    OUT0( "        break ;\n" ) ;\
    OUT0( "      case JD_D_sbit:\n" ) ;\
    OUT0( "        TMP_DT->data.int_value = dt->data.sbit.a ;\n" ) ;\
    OUT0( "        /* may check if b is zero or not */\n" ) ;\
    OUT0( "        break ;\n" ) ;\
    OUT0( "      case JD_D_float:\n" ) ;\
    OUT0( "        TMP_DT->data.int_value = dt->data.float_value ;\n" ) ;\
    OUT0( "        break ;\n" ) ;\
    OUT0( "      case JD_D_double:\n" ) ;\
    OUT0( "        TMP_DT->data.int_value = dt->data.double_value ;\n" ) ;\
    OUT0( "        break ;\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_copy_arg_single_int() ;\n" ) ; \
  }
#  define CALL_EXEC_COPY_ARG_SINGLE_FLOAT  JD_exec_copy_arg_single_float()
#define OUT_EXEC_COPY_ARG_SINGLE_FLOAT \
    OUT0( "JD_exec_copy_arg_single_float() ;\n" ) ; 
#  define CALL_EXEC_COPY_ARG_SINGLE_DOUBLE  JD_exec_copy_arg_single_double()
#define OUT_EXEC_COPY_ARG_SINGLE_DOUBLE \
    OUT0( "JD_exec_copy_arg_single_double() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_COPY_ARG_SINGLE_BIT  { \
   { \
     JD_data *dt ;\
     double sft, flt ;\
     int msk, i, n ;\
     \
     dt = STACK[THREAD->stk_frame-TMP_INT] ;\
     if( IS_SMLINT(dt) ) {\
       int x = SMLINT2INT(dt) ;\
       if( TMP_DT->type == JD_D_sbit ) {\
         msk = BITMASK(TMP_DT->data.sbit.size) ;\
         TMP_DT->data.sbit.a = x & msk ;\
         TMP_DT->data.sbit.b = 0 ;\
       }\
       else {\
         n = LASTWORD(TMP_DT->data.bit.size) ;\
         if( n ) {\
           TMP_DT->data.bit.a[0] = x ;\
           TMP_DT->data.bit.b[0] = 0 ;\
           for( i = 1 ; i <= n ; i++ ) {\
             TMP_DT->data.bit.a[i] = 0 ;\
             TMP_DT->data.bit.b[i] = 0 ;\
           }\
         }\
         else {\
           msk = BITMASK(TMP_DT->data.sbit.size) ;\
           TMP_DT->data.bit.a[0] = x & msk ;\
           TMP_DT->data.bit.b[0] = 0 ;\
         }\
       }\
     }\
     else switch(dt->type) {\
       case JD_D_int:\
         if( TMP_DT->type == JD_D_sbit ) {\
           msk = BITMASK(TMP_DT->data.sbit.size) ;\
           TMP_DT->data.sbit.a = dt->data.int_value & msk ;\
           TMP_DT->data.sbit.b = 0 ;\
         }\
         else {\
           n = LASTWORD(TMP_DT->data.bit.size) ;\
           if( n ) {\
             TMP_DT->data.bit.a[0] = dt->data.int_value ;\
             TMP_DT->data.bit.b[0] = 0 ;\
             for( i = 1 ; i <= n ; i++ ) {\
               TMP_DT->data.bit.a[i] = 0 ;\
               TMP_DT->data.bit.b[i] = 0 ;\
             }\
           }\
           else {\
             msk = BITMASK(TMP_DT->data.sbit.size) ;\
             TMP_DT->data.bit.a[0] = dt->data.int_value & msk ;\
             TMP_DT->data.bit.b[0] = 0 ;\
           }\
         }\
         break ;\
       case JD_D_bit:\
         if( TMP_DT->type == JD_D_sbit ) {\
           msk = BITMASK(TMP_DT->data.sbit.size) ;\
           TMP_DT->data.sbit.a = dt->data.bit.a[0] & msk ;\
           TMP_DT->data.sbit.b = dt->data.bit.b[0] & msk ;\
         }\
         else {\
           int i, n ;\
           if (dt->data.bit.size < TMP_DT->data.bit.size) {\
             n = LASTWORD(dt->data.bit.size) ;\
             for( i = 0 ; i <=n ; i++ ) {\
               TMP_DT->data.bit.a[i] = dt->data.bit.a[i] ;\
               TMP_DT->data.bit.b[i] = dt->data.bit.b[i] ;\
             }\
             n = LASTWORD(TMP_DT->data.bit.size) ;\
             for( ; i <= n ; i++ ) {\
               TMP_DT->data.bit.a[i] = 0 ;\
               TMP_DT->data.bit.b[i] = 0 ;\
             }\
           }\
           else {\
             n = LASTWORD(TMP_DT->data.bit.size) ;\
             msk = BITMASK(TMP_DT->data.bit.size) ;\
             for( i = 0 ; i < n ; i++ ) {\
               TMP_DT->data.bit.a[i] = dt->data.bit.a[i] ;\
               TMP_DT->data.bit.b[i] = dt->data.bit.b[i] ;\
             }\
             TMP_DT->data.bit.a[n] = dt->data.bit.a[n] & msk ;\
             TMP_DT->data.bit.b[n] = dt->data.bit.b[n] & msk ;\
           }\
         }\
         break ;\
       case JD_D_sbit:\
         if( TMP_DT->type == JD_D_sbit ) {\
           msk = BITMASK(TMP_DT->data.sbit.size) ;\
           TMP_DT->data.sbit.a = dt->data.sbit.a & msk ;\
           TMP_DT->data.sbit.b = dt->data.sbit.b & msk ;\
         }\
         else {\
           TMP_DT->data.bit.a[0] = dt->data.sbit.a ;\
           TMP_DT->data.bit.b[0] = dt->data.sbit.b ;\
           n = LASTWORD(TMP_DT->data.bit.size) ;\
           for( i = 1 ; i <= n ; i++ ) {\
             TMP_DT->data.bit.a[i] = 0 ;\
             TMP_DT->data.bit.b[i] = 0 ;\
           }\
         }\
         break ;\
       case JD_D_float:\
         if( TMP_DT->type == JD_D_sbit ) {\
           TMP_DT->data.sbit.a = dt->data.float_value ;\
           TMP_DT->data.sbit.b = 0 ;\
         }\
         else {\
           sft = 2.0 ;\
           n = LASTWORD(TMP_DT->data.bit.size) ;\
           for( i = 0 ; i <= n ; i++ ) {\
             TMP_DT->data.bit.a[i] = 0 ;\
             TMP_DT->data.bit.b[i] = 0 ;\
           }\
           for( i = 0 ; i < 32 ; i++ ) sft *= 2.0 ;\
           i = 0 ;\
           flt = dt->data.float_value ;\
           while( flt > 1.0 ) {\
             ACC_A[i++] = fmod(flt,sft) ;\
             flt /= sft ;\
             if( i == n ) break ;\
           }\
         }\
         break ;\
       case JD_D_double:\
         if( TMP_DT->type == JD_D_sbit ) {\
           TMP_DT->data.sbit.a = dt->data.double_value ;\
           TMP_DT->data.sbit.b = 0 ;\
         }\
         else {\
           sft = 2.0 ;\
           n = LASTWORD(TMP_DT->data.bit.size) ;\
           for( i = 0 ; i <= n ; i++ ) {\
             TMP_DT->data.bit.a[i] = 0 ;\
             TMP_DT->data.bit.b[i] = 0 ;\
           }\
           for( i = 0 ; i < 32 ; i++ ) sft *= 2.0 ;\
           i = 0 ;\
           flt = dt->data.double_value ;\
           while( flt > 1.0 ) {\
             ACC_A[i++] = fmod(flt,sft) ;\
             flt /= sft ;\
             if( i == n ) break ;\
           }\
         }\
         break ;\
       case JD_D_string:\
         if( TMP_DT->type == JD_D_sbit ) \
         {\
           int nb, j ;\
           nb = (TMP_DT->data.sbit.size)/8 ;\
           j = 0 ;\
           TMP_DT->data.sbit.a = TMP_DT->data.sbit.b = 0 ;\
           for(  ; nb > 0 ; nb-- ) {\
             TMP_DT->data.sbit.a = \
               (TMP_DT->data.sbit.a << 8) | \
               ( ( dt->data.string[j] != NULL_CHAR)?dt->data.string[j++]:0 ) ;\
           }\
         }\
         else {\
           int nw, nb, size, j ;\
           size = TMP_DT->data.bit.size/8 ;\
           size *= 8 ; /* round to 8 */\
           nw = LASTWORD(size) ;\
           j = 0 ;\
           nb = (size%32)/8 ;\
           if( nb == 0 ) nb = 4 ;\
           for(  ; nw >= 0 ; nw-- ) {\
             TMP_DT->data.bit.a[nw] = TMP_DT->data.bit.b[nw] = 0 ;\
             for(  ; nb > 0 ; nb-- ) {\
               TMP_DT->data.bit.a[nw] = \
                 (TMP_DT->data.bit.a[nw] << 8) | \
                 ( ( dt->data.string[j] != NULL_CHAR)?dt->data.string[j++]:0 ) ;\
             }\
             nb = 4 ;\
           }\
         }\
         break ;\
     }\
   }\
  }
#else
#  define CALL_EXEC_COPY_ARG_SINGLE_BIT  JD_exec_copy_arg_single_bit()
#endif
#define OUT_EXEC_COPY_ARG_SINGLE_BIT \
    OUT0( "JD_exec_copy_arg_single_bit() ;\n" ) ; 
#ifdef JEDA_INLINE_OPTIMIZATION
#  define CALL_EXEC_COPY_ARG_SINGLE_OBJ  { \
   { \
     JD_data *dt ;\
     \
     dt = STACK[THREAD->stk_frame-TMP_INT] ;\
     if( dt->type == JD_D_null ) TMP_DT->data.obj.ect = NULL ;\
     else {\
       TMP_DT->data.obj.ect = dt->data.obj.ect ;\
       if( TMP_DT->data.obj.ect ) TMP_DT->data.obj.ect->ref_count++ ;\
 \
       TMP_DT->data.obj.alloc = dt->data.obj.alloc ;\
     }\
   }\
  }
#else
#  define CALL_EXEC_COPY_ARG_SINGLE_OBJ  JD_exec_copy_arg_single_obj()
#endif
#define OUT_EXEC_COPY_ARG_SINGLE_OBJ \
  if( inline_optimization ) {  \
    OUT0( "    /* Macro for JD_exec_copy_arg_single_obj */ \n" ) ; \
    OUT0( "  { \n" ) ;\
    OUT0( "    JD_data *dt ;\n" ) ;\
    OUT0( "    \n" ) ;\
    OUT0( "    dt = STACK[THREAD->stk_frame-TMP_INT] ;\n" ) ;\
    OUT0( "    if( dt->type == JD_D_null ) TMP_DT->data.obj.ect = NULL ;\n" ) ;\
    OUT0( "    else {\n" ) ;\
    OUT0( "      TMP_DT->data.obj.ect = dt->data.obj.ect ;\n" ) ;\
    OUT0( "      if( TMP_DT->data.obj.ect ) TMP_DT->data.obj.ect->ref_count++ ;\n" ) ;\
    OUT0( "\n" ) ;\
    OUT0( "      TMP_DT->data.obj.alloc = dt->data.obj.alloc ;\n" ) ;\
    OUT0( "    }\n" ) ;\
    OUT0( "  }\n" ) ;\
  } \
  else { \
    OUT0( "JD_exec_copy_arg_single_obj() ;\n" ) ; \
  }
#  define CALL_EXEC_COPY_ARG_SINGLE_STRING  JD_exec_copy_arg_single_string()
#define OUT_EXEC_COPY_ARG_SINGLE_STRING \
    OUT0( "JD_exec_copy_arg_single_string() ;\n" ) ; 
#  define CALL_EXEC_COPY_ARG_SINGLE_SIGNAL  JD_exec_copy_arg_single_signal()
#define OUT_EXEC_COPY_ARG_SINGLE_SIGNAL \
    OUT0( "JD_exec_copy_arg_single_signal() ;\n" ) ; 
#  define CALL_EXEC_COPY_ARG_SINGLE_THREAD  JD_exec_copy_arg_single_thread()
#define OUT_EXEC_COPY_ARG_SINGLE_THREAD \
    OUT0( "JD_exec_copy_arg_single_thread() ;\n" ) ; 
#  define CALL_EXEC_ARG_NON_SINGLE  JD_exec_arg_non_single()
#define OUT_EXEC_ARG_NON_SINGLE \
    OUT0( "JD_exec_arg_non_single() ;\n" ) ; 
#  define CALL_EXEC_STORE_ADJUST_INT  JD_exec_store_adjust_int()
#define OUT_EXEC_STORE_ADJUST_INT \
    OUT0( "JD_exec_store_adjust_int() ;\n" ) ; 
#  define CALL_EXEC_STORE_ADJUST_BIT  JD_exec_store_adjust_bit()
#define OUT_EXEC_STORE_ADJUST_BIT \
    OUT0( "JD_exec_store_adjust_bit() ;\n" ) ; 
#  define CALL_EXEC_SAVE_ACC  JD_save_acc()
#define OUT_EXEC_SAVE_ACC \
    OUT0( "JD_save_acc() ;\n" ) ; 
#  define CALL_EXEC_RESTORE_ACC  JD_restore_acc()
#define OUT_EXEC_RESTORE_ACC \
    OUT0( "JD_restore_acc() ;\n" ) ; 
#  define CALL_EXEC_GET_RETURN  JD_get_return()
#define OUT_EXEC_GET_RETURN \
    OUT0( "JD_get_return() ;\n" ) ; 
